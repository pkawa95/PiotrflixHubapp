<!DOCTYPE html>
<html lang="pl">
<head>
  <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/static/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/static/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon-precomposed.png">



  <!-- Wymagane przez iOS -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Piotrflix">
<link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0b0b12">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#f5f7fb">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#000000">

<link rel="icon" href="/static/favicon.ico" type="image/x-icon">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#000000">

  <meta charset="UTF-8">
  <title>Piotrflix</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<style>
  /* ===== NAWIGACJA – pełny gotowiec ===== */
  .nawigacja{
    --navx-bg-dark: rgba(16,18,28,.92);
    --navx-bg-light: rgba(255,255,255,.94);
    --navx-sep-dark: rgba(255,255,255,.12);
    --navx-sep-light: rgba(0,0,0,.10);
    --navx-accent: #7c3aed;     /* fiolet */
    --navx-accent-2: #06b6d4;  /* niebieski */
    --navx-safe: env(safe-area-inset-bottom, 0px);

    position: fixed;
    left: 0; right: 0; bottom: 0;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    padding: 0 0 var(--navx-safe);
    margin: 0;

    background: var(--navx-bg-dark);
    border-top: 1px solid rgba(255,255,255,.15);
    box-shadow: 0 -6px 14px rgba(0,0,0,.3);
    backdrop-filter: blur(12px) saturate(120%);
    -webkit-backdrop-filter: blur(12px) saturate(120%);
    z-index: 999;
  }
  body[data-theme="light"] .nawigacja{
    background: var(--navx-bg-light);
    border-top: 1px solid var(--navx-sep-light);
    box-shadow: 0 -6px 12px rgba(0,0,0,.1);
  }

  .nawigacja__btn{
    appearance: none; -webkit-appearance: none;
    background: transparent; border: 0; outline: 0;
    display: grid; place-items: center;
    grid-template-rows: 24px auto;
    padding: .7rem .25rem .65rem;
    margin: 0; border-radius: 0;
    color: inherit; font: inherit; font-weight: 700;
    font-size: .9rem; line-height: 1;
    cursor: pointer; user-select: none;
    position: relative;
    transition: background .18s ease, color .18s ease, transform .1s ease;
  }
  .nawigacja__btn::after{ content:none !important; }

  .nawigacja__btn:not(:last-child){
    border-right: 1px solid var(--navx-sep-dark);
  }
  body[data-theme="light"] .nawigacja__btn:not(:last-child){
    border-right: 1px solid var(--navx-sep-light);
  }

  .nawigacja__ico{
    width: 22px; height: 22px;
    display: inline-block;
    color: #fff;
    transition: transform .12s ease, color .12s ease;
  }
  .nawigacja__ico svg{ width:100%; height:100%; fill: currentColor; }

  .nawigacja__label{
    margin-top: .25rem;
    font-size: .78rem;
    letter-spacing: .2px;
    color: #fff;
  }
  body[data-theme="light"] .nawigacja__ico,
  body[data-theme="light"] .nawigacja__label{ color:#000; }

  @media (hover:hover){
    .nawigacja__btn:hover{ color: var(--navx-accent-2); }
    .nawigacja__btn:hover .nawigacja__ico{ transform: translateY(-2px); }
  }
  .nawigacja__btn:active{ transform: translateY(1px); }

  .nawigacja__btn.is-active{
    background: linear-gradient(135deg, var(--navx-accent) 0%, var(--navx-accent-2) 92%);
    color:#fff !important;
  }
  .nawigacja__btn.is-active .nawigacja__ico,
  .nawigacja__btn.is-active .nawigacja__label{ color:#fff !important; }
  .nawigacja__btn.is-active::before{
    content:"";
    position:absolute; left:0; right:0; bottom:0; height:3px;
    background: linear-gradient(90deg, var(--navx-accent-2), var(--navx-accent));
    transform-origin:left;
    animation: navx-underline .18s ease both;
  }
  @keyframes navx-underline{ from{ transform:scaleX(0) } to{ transform:scaleX(1) } }

  body[data-theme="light"] .nawigacja__btn{ color:#000; }

  @media (max-width:600px){
    .nawigacja__btn{ grid-template-rows: 22px auto; padding:.6rem .15rem .55rem; }
    .nawigacja__label{ font-size:.74rem; }
  }
/* ============ CAST: mini player + modal ============ */

/* Ustal wysokość dolnego menu i luz nad nim */
:root{
  --cast-ui-height: 110px;
  --nav-height: 64px;   /* wysokość #nav */
  --cast-gap: 12px;     /* oddech nad #nav */
}

/* Mini-player zawsze ponad treścią i ponad nav */
#cast-bar{
  position: fixed;
  left: 0; right: 0;
  /* PODNIESIONY: siedzi nad #nav i bezpiecznym obszarem */
  bottom: calc(var(--nav-height) + var(--cast-gap) + env(safe-area-inset-bottom));
  display: none; align-items: center; gap: .9rem;
  padding: .65rem .9rem;
  background: var(--nav-bg-dark);
  color: inherit; border-top: 1px solid rgba(255,255,255,.08);
  box-shadow: 0 -8px 22px rgba(0,0,0,.35);
  z-index: 1001; /* > #nav (który ma 999) */
}
body[data-theme="light"] #cast-bar{
  background: var(--nav-bg-light);
  border-top: 1px solid rgba(0,0,0,.06);
  box-shadow: 0 -8px 16px rgba(0,0,0,.12);
}

/* Mobile: odrobinę większy margines nad nav (często wyższy) */
@media (max-width: 600px){
  :root{
    --nav-height: 72px;  /* jeśli Twoje #nav jest wyższe, podnieś tu */
    --cast-gap: 14px;
  }
  #cast-thumb{ width:52px; height:52px; }
}

/* (Opcjonalnie) Gdy player jest widoczny – dołóż miejsca pod treścią,
   żeby nic nie chowało się pod paskiem mini-playera (działa w nowoczesnych przeglądarkach) */
@supports selector(body:has(#cast-bar)){
  body:has(#cast-bar[style*="display: flex"]) .container{
    padding-bottom: calc(
      max(7rem, 5rem) + var(--nav-height) + var(--cast-gap) + env(safe-area-inset-bottom)
    );
  }
}

/* Reszta bez zmian */
#cast-thumb{
  width: 56px; height: 56px; object-fit: cover; border-radius: 10px;
  box-shadow: 0 8px 18px rgba(0,0,0,.35);
}
#cast-title{
  font-weight: 800; font-size: .98rem; line-height: 1.2;
  margin-bottom: .25rem; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
  max-width: 44vw;
}
#cast-time{ font-variant-numeric: tabular-nums; opacity:.9; font-size:.9rem; }
#cast-seek{
  flex: 1 1 auto; width: 100%;
  -webkit-appearance: none; appearance: none;
  height: 8px; border-radius: 999px;
  background: linear-gradient(180deg,#1b1b29,#131320);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
}
#cast-seek::-webkit-slider-thumb{
  -webkit-appearance: none; appearance: none;
  width: 16px; height: 16px; border-radius: 50%;
  background: linear-gradient(135deg,var(--accent),var(--accent-2));
  box-shadow: 0 0 0 2px rgba(255,255,255,.25);
  cursor: pointer;
}
#cast-seek::-moz-range-thumb{
  width: 16px; height: 16px; border-radius: 50%;
  background: linear-gradient(135deg,var(--accent),var(--accent-2));
  border: 0; cursor: pointer;
}
.cast-controls{ display:flex; align-items:center; gap:.4rem; }
.cast-controls button{
  width: 38px; height: 38px; border-radius: 10px;
  display: inline-flex; align-items: center; justify-content: center;
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  color: inherit; border: var(--border-glass);
  box-shadow: var(--shadow-card);
  padding: 0; font-size: 1rem;
}

/* Modal wyboru urządzenia — bez zmian */
#cast-modal{
  position: fixed; inset: 0; display: none;
  align-items: center; justify-content: center; z-index: 1002;
  background: rgba(0,0,0,.6); backdrop-filter: blur(4px);
}
#cast-modal.show{ display: flex; }
#cast-modal .modal-inner{
  width: min(92vw, 440px);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  color: var(--color-dark);
  padding: 1rem; border-radius: 16px; border: var(--border-glass);
  box-shadow: var(--shadow-card);
}
body[data-theme="light"] #cast-modal .modal-inner{
  background: var(--card-bg-light); color: var(--color-light);
}
#cast-devices{ margin:.6rem 0 .8rem; max-height: 50vh; overflow:auto; }
.cast-device{
  display:flex; align-items:center; justify-content:space-between;
  gap:.6rem; padding:.6rem .7rem; border-radius: 12px;
  border: var(--border-glass); margin-bottom:.5rem;
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  cursor: pointer;
}
.cast-device.selected{
  outline: 2px solid rgba(0,240,255,.45); box-shadow: var(--glow-soft);
}
#cast-modal .actions{ display:flex; gap:.6rem; }
#cast-confirm[disabled]{ opacity:.6; cursor:not-allowed; }


/* ========== SERIALE v2 (desktop + mobile) ========== */
#available-series{
  display:grid;
  grid-template-columns: repeat(auto-fill,minmax(320px,1fr));
  gap:16px;
}

/* karta serialu jako <details> */
details.series-card{
  display:block;
  padding:14px;
  border-radius:18px;
  border:var(--border-glass);
  box-shadow:var(--shadow-card);
  background:var(--card-bg-dark);
}
body[data-theme="light"] details.series-card{ background:var(--card-bg-light); }

/* chowamy marker <summary> */
details.series-card > summary{ list-style:none; cursor:pointer; }
details.series-card > summary::-webkit-details-marker{ display:none; }

/* TOP: poster | info | caret */
.series-top{
  display:grid;
  grid-template-columns: 86px 1fr 18px;
  gap:12px;
  align-items:start;
}
.series-poster{
  width:86px; aspect-ratio:2/3; object-fit:cover;
  border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.35);
}
.series-main{ min-width:0; }
.series-title{
  margin:0 0 .25rem; font-weight:800; font-size:1.05rem; line-height:1.25; overflow-wrap:anywhere;
}
.series-caret{ font-weight:900; opacity:.7; transform:rotate(0deg); transition:transform .18s ease; }
details.series-card[open] .series-caret{ transform:rotate(90deg); }

/* progress */
.series-progress{ margin:.15rem 0 .35rem; }
.series-progress .bar{
  height:8px; border-radius:8px; overflow:hidden;
  background:linear-gradient(180deg,#1b1b29,#131320);
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);
}
.series-progress .fill{
  height:100%; width:0; transition:width .4s ease;
  background:linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 60%, var(--accent-3) 100%);
}

/* timer + przyciski */
.series-timer{
  display:flex; gap:.5rem; align-items:center; justify-content:flex-end; flex-wrap:wrap;
  margin-top:.25rem;
}
.btn-danger{
  background: linear-gradient(135deg, #ff3b30 0%, #ff9500 92%) !important;
  color:#fff !important; padding:.5rem .8rem; border-radius:12px; font-weight:800; border:none;
}

/* chipsy sezonów */
.season-chips{
  display:grid; grid-template-columns: repeat(auto-fill,minmax(120px,1fr));
  gap:8px; margin-top:.6rem;
}
.chip{
  display:flex; align-items:center; gap:.5rem;
  padding:.45rem .7rem; border-radius:12px;
  background:rgba(255,255,255,.06); border:var(--border-glass);
}
.chip .num{ font-weight:800; }
.chip .meta{ opacity:.85; font-size:.9rem; }
.chip.done{ background:linear-gradient(135deg, #27ae60 0%, #36d17c 90%); color:#fff; border:none; }

/* rozwijane listy sezonów/odcinków */
.series-seasons{ margin-top:.6rem; }
.series-seasons details{
  margin-bottom:.45rem; background:rgba(255,255,255,.04);
  border:var(--border-glass); border-radius:10px; padding:.45rem .6rem;
}
.series-seasons summary{ display:flex; align-items:center; gap:.5rem; cursor:pointer; font-weight:700; }
.series-seasons ul{ margin:.35rem 0 0; padding-left:1.1rem; }
.series-seasons li{ margin:.25rem 0; font-size:.92rem; }

/* mobile */
@media (max-width: 600px){
  #available-series{ grid-template-columns: 1fr; }
  .series-top{ grid-template-columns: 64px 1fr 18px; gap:.8rem; }
  .series-poster{ width:64px; }
}

  /* ============ ROOT / THEME ============ */
  :root{
    --bg-dark:#0b0b12; --bg-light:#f5f7fb;
    --card-bg-dark:rgba(22,22,34,.78);
    --card-bg-light:rgba(255,255,255,.86);
    --color-dark:#eef2ff; --color-light:#0a0a0f;

    --accent:#c600ff; --accent-2:#00f0ff; --accent-3:#7cff00;
    --glow-soft:0 0 12px rgba(198,0,255,.35),0 0 24px rgba(0,240,255,.22);
    --glow-strong:0 0 18px rgba(198,0,255,.6),0 0 40px rgba(0,240,255,.5);
    --border-glass:1px solid rgba(255,255,255,.18);
    --shadow-card:0 10px 30px rgba(0,0,0,.35);
    --radius-lg:14px; --radius-xl:20px;

    --aurora-1:radial-gradient(60% 80% at 10% 10%,rgba(198,0,255,.18),transparent 60%);
    --aurora-2:radial-gradient(70% 90% at 90% 20%,rgba(0,240,255,.16),transparent 60%);
    --aurora-3:radial-gradient(60% 60% at 70% 80%,rgba(124,255,0,.14),transparent 60%);
    --sheen:linear-gradient(120deg,rgba(255,255,255,0) 25%,rgba(255,255,255,.22) 45%,rgba(255,255,255,0) 60%);

    --nav-bg-dark:rgba(16,18,28,.92);
    --nav-bg-light:rgba(255,255,255,.94);
  }

  /* Solid fallback tła (eliminuje białe mignięcia) */
  html,body{background-color:#0b0b12;}
  @media (prefers-color-scheme:light){ html,body{background-color:#f5f7fb;} }

  body[data-theme="dark"]{
    color:var(--color-dark);
    background:
      var(--aurora-1),var(--aurora-2),var(--aurora-3),
      radial-gradient(1200px 800px at 50% 120%, #06060a 20%, var(--bg-dark) 60%);
    background-attachment:scroll;
  }
  body[data-theme="light"]{
    color:var(--color-light);
    background:
      radial-gradient(900px 600px at -10% -10%, rgba(198,0,255,.10), transparent 60%),
      radial-gradient(900px 600px at 110% 0%, rgba(0,240,255,.10), transparent 60%),
      linear-gradient(180deg, #ffffff 0%, var(--bg-light) 100%);
    background-attachment:scroll;
  }

  /* Delikatna animacja aurory (bez fixed) */
  @media (prefers-reduced-motion:no-preference){
    body::before{
      content:""; position:fixed; inset:-20% -10%; pointer-events:none; z-index:0;
      background:
        radial-gradient(50% 60% at 30% 20%, rgba(198,0,255,.18), transparent 60%),
        radial-gradient(55% 65% at 70% 30%, rgba(0,240,255,.16), transparent 60%);
      filter:blur(42px) saturate(125%);
      animation:auroraMove 18s ease-in-out infinite alternate;
    }
    @keyframes auroraMove{0%{transform:translate3d(0,0,0) scale(1)}100%{transform:translate3d(-2%,1.5%,0) scale(1.03)}}
  }

  /* ===== FIX 1: notch / bez przycięcia góry ===== */
  *{-webkit-tap-highlight-color:transparent;}
  html,body{
    margin:0; padding:0;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";
    scroll-behavior:smooth;
    transition:background-color .3s,color .3s;
    min-height:100svh;             /* stabilna wysokość na iOS/Safari */
  }
  /* globalny top padding na wszystkich trybach (Safari + PWA) */
  body{
    padding-top:calc(env(safe-area-inset-top, 0px) + 8px);
    overscroll-behavior-y:none;
  }
  /* w PWA dodatkowo bottom safe-area dla nav poniżej */
  @media all and (display-mode:standalone){
    #nav{padding-bottom:calc(.8rem + env(safe-area-inset-bottom));}
  }

  .container{
    position:relative; z-index:1; max-width:960px; margin:auto;
    padding:1rem clamp(1rem,3vw,2rem);
    padding-bottom:max(7rem, calc(5rem + env(safe-area-inset-bottom)));
    animation:fadeIn .5s ease;
  }
  @keyframes fadeIn{from{opacity:0; transform:translateY(14px)}to{opacity:1; transform:translateY(0)}}

  h1{
    font-size:clamp(1.9rem,3.6vw,2.4rem); margin:.2rem 0 1rem; text-align:center; letter-spacing:.4px;
    background:linear-gradient(90deg,#fff,#d7d7ff 30%,#ffffff 60%);
    -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow:var(--glow-soft);
  }

  /* ====== Inputs / Selects / Buttons ====== */
  input,select,button{
    width:100%; padding:.9rem 1rem; margin:.5rem 0; font-size:1rem;
    border-radius:var(--radius-lg); border:none; outline:none;
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
    color:inherit; box-shadow:inset 0 1px 0 rgba(255,255,255,.06), var(--shadow-card);
    backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
    transition:transform .15s ease, box-shadow .3s ease, background .3s ease;
  }
  input:focus,select:focus{box-shadow:0 0 0 2px rgba(198,0,255,.35),0 0 0 6px rgba(0,240,255,.18), var(--shadow-card);}

  button{
    cursor:pointer; background:linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 70%);
    color:white; border-radius:var(--radius-xl); box-shadow:var(--glow-strong); position:relative; overflow:hidden;
  }
  button::after{content:""; position:absolute; inset:0; background:var(--sheen); transform:translateX(-120%); transition:transform .6s ease; mix-blend-mode:screen;}
  button:hover::after{transform:translateX(0%);} button:hover{transform:translateY(-1px) scale(1.01);} button:active{transform:translateY(0) scale(.995);}
  button:hover{filter:drop-shadow(0 0 10px rgba(0,240,255,.25));}

  /* ====== Cards / Tiles ====== */
  .series-card,.torrent,.search-result,.browse-result{
    background:var(--card-bg-dark); color:var(--color-dark);
    padding:1rem; margin-bottom:1.1rem; border-radius:var(--radius-xl); border:var(--border-glass);
    box-shadow:var(--shadow-card), var(--glow-soft);
    backdrop-filter:blur(14px) saturate(120%); -webkit-backdrop-filter:blur(14px) saturate(120%);
    max-width:100%; display:flex; gap:1rem; transition:transform .18s ease, box-shadow .3s ease, background .3s ease;
  }
  body[data-theme="light"] .series-card,
  body[data-theme="light"] .torrent,
  body[data-theme="light"] .search-result,
  body[data-theme="light"] .browse-result{color:var(--color-light); background:var(--card-bg-light);}
  .series-card:hover,.torrent:hover,.search-result:hover,.browse-result:hover{
    transform:translateY(-2px);
    box-shadow:var(--shadow-card),0 0 0 1px rgba(255,255,255,.06), var(--glow-strong);
  }
  /* Torrent rows */
  .torrent{justify-content:space-between; align-items:flex-start; flex-wrap:wrap;}
  .torrent-info{flex:1; min-width:60%;}
  .torrent-name{font-weight:800; margin-bottom:.28rem;}
  .torrent-details{font-size:.95rem; color:#c6cbff; margin:.3rem 0;}
  body[data-theme="light"] .torrent-details{color:#6a6a8a;}

  /* Progress bars */
  .progress-bar{background:linear-gradient(180deg,#1b1b29,#131320); border-radius:8px; overflow:hidden; height:12px; width:100%; box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);}
  .progress-bar-inner,.series-info .progress-fill{background:linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 60%, var(--accent-3) 100%); box-shadow:0 0 12px rgba(198,0,255,.6); height:100%; width:0%; min-width:2%; transition:width .5s ease;}

  /* ====== GÓRNE TABS – sticky pod statusem ====== */
  .search-tabs{
    position:sticky;
    top:calc(env(safe-area-inset-top, 0px) + 8px);  /* bez wjeżdżania pod notch */
    display:flex; gap:0; overflow-x:auto; -webkit-overflow-scrolling:touch;
    border-radius:var(--radius-xl);
    background:var(--nav-bg-dark); border:1px solid rgba(255,255,255,.08);
    box-shadow:0 6px 22px rgba(0,0,0,.35), var(--glow-soft);
    backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
    z-index:5; margin-bottom:1rem;
  }
  body[data-theme="light"] .search-tabs{background:var(--nav-bg-light); border-color:rgba(0,0,0,.06);}
  .search-tab{
    flex:1 0 auto; min-width:112px;
    padding:.7rem 1rem; font-size:1rem; font-weight:700; letter-spacing:.2px;
    border:none; background:transparent; color:inherit; text-align:center; border-bottom:2px solid transparent; position:relative; overflow:hidden;
  }
  .search-tab::after{content:""; position:absolute; inset:0; background:var(--sheen); transform:translateX(-120%); transition:transform .6s ease;}
  .search-tab:hover::after{transform:translateX(0%);}
  .search-tab.active{
    background:linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 80%);
    color:white; border-bottom:2px solid white; box-shadow:var(--glow-strong) inset, var(--glow-soft);
  }

.available-tab-content{ display:none !important; }
.available-tab-content.active{ display:block !important; }

  /* ===== FIX 2: #torrent-tabs – 2 przyciski bez przewijania ===== */
  #torrent-tabs{
    overflow-x:hidden;            /* brak paska przewijania */
    justify-content:center;
    gap:.5rem;
  }
  #torrent-tabs .search-tab{
    min-width:auto !important;    /* nadpisuje min-width:112px */
    flex:1 1 50%;                 /* 2 równe przyciski obok siebie */
    max-width:none;
    white-space:nowrap;
  }
  @media (max-width:360px){
    #torrent-tabs .search-tab{padding:.6rem .5rem; font-size:.95rem;}
  }

  /* ====== Filters ====== */
  #browse-filters{display:flex; flex-wrap:wrap; gap:1rem; margin-bottom:1rem;}
  .filter-group{display:flex; flex-direction:column; flex:1 1 48%; min-width:160px;}
  @media (max-width:600px){ .filter-group{flex:1 1 100%;} }
  .filter-group label{margin-bottom:.35rem; font-weight:700; font-size:.9rem;}

  /* ====== Toggles ====== */
  .theme-toggle-container{position:fixed; bottom:7rem; right:1rem; z-index:999;}
  .switch-label{display:flex; align-items:center; gap:.6rem; font-size:1rem; margin:1rem 0; cursor:pointer;}
  .switch-label.small{font-size:.8rem; gap:.3rem; margin:.5rem 0;}
  .switch-input{opacity:0; width:0; height:0;}
  .switch-slider{position:relative; display:inline-block; width:54px; height:28px; background:linear-gradient(180deg,#2a2a40,#19192a); border-radius:50px; transition:background .3s, box-shadow .3s; box-shadow:inset 0 0 0 1px rgba(255,255,255,.08), var(--glow-soft);}
  .switch-slider::before{content:""; position:absolute; height:22px; width:22px; left:3px; top:3px; background:radial-gradient(circle at 30% 30%, #fff, #dfe5ff); border-radius:50%; transition:transform .3s; box-shadow:0 2px 10px rgba(0,0,0,.35);}
  .switch-input:checked + .switch-slider{background:linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 80%); box-shadow:var(--glow-strong) inset, var(--glow-soft);}
  .switch-input:checked + .switch-slider::before{transform:translateX(26px);}
  .switch-label.small .switch-slider{width:40px; height:20px;} .switch-label.small .switch-slider::before{height:16px; width:16px; top:2px; left:2px;}
  .switch-label.small .switch-input:checked + .switch-slider::before{transform:translateX(20px);}

  /* ====== Logo ====== */
  .logo-container{text-align:center; margin-bottom:1rem;}
  .logo-img{max-width:100%; height:auto; width:260px; filter:drop-shadow(0 8px 24px rgba(198,0,255,.3));}
  @media (max-width:500px){ .logo-img{width:180px;} }

  .hidden{display:none !important;}

  /* ====== Buttons row ====== */
  .torrent-buttons-row{display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem;}
  .torrent-buttons-row button{flex:0 0 auto; padding:.45rem .9rem; font-size:.9rem; border-radius:10px; white-space:nowrap; width:auto !important;}
  .torrent-buttons button{flex:1; margin:.2rem; font-size:.92rem;}
  .reset-btn{
    font-size:12px; padding:4px 6px; background:linear-gradient(135deg,#27ae60,#36d17c);
    color:white; border:none; border-radius:8px; cursor:pointer; line-height:1; height:26px; white-space:nowrap; display:inline-block; text-align:center; margin-left:8px; width:auto; box-shadow:0 6px 18px rgba(39,174,96,.35);
  }
  .reset-btn:hover{filter:brightness(1.05); transform:translateY(-1px);}

  /* ====== Result cards ====== */
  .search-result img,.browse-result img{width:100px; border-radius:12px; object-fit:cover; box-shadow:0 10px 24px rgba(0,0,0,.35);}
  .result-content{flex:1; display:flex; flex-direction:column; gap:.6rem; justify-content:space-between;}
  .torrent-title,.torrent-name,.search-result .result-content b,.browse-result .result-content b{
    font-size:clamp(.98rem,3.5vw,1.08rem); line-height:1.3; margin:0; word-break:break-word; overflow-wrap:anywhere; letter-spacing:.2px;
  }
  .search-result .result-content > div:first-child,.browse-result .result-content > div:first-child{display:flex; flex-wrap:wrap; gap:.35rem;}

  /* ====== Sections ====== */
  .section{display:none;}
  .section.active{display:block; animation:fadeIn .4s ease;}

  /* ====== Browse controls ====== */
  #browse-filters select{width:49%; display:inline-block; margin:.5% 0;}
  #browse-pagination{text-align:center; margin-top:1rem;}

  /* ====== Modal ====== */
  #quality-modal{display:none; position:fixed; inset:0; background:rgba(0,0,0,.68); align-items:center; justify-content:center; z-index:1000; backdrop-filter:blur(4px);}
  #quality-modal .modal-content{
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    color:var(--color-dark); padding:1.5rem; border-radius:var(--radius-xl); width:90%; max-width:380px; text-align:center;
    border:var(--border-glass); box-shadow:var(--shadow-card), var(--glow-soft);
  }

  /* ====== Responsive tuning ====== */
  @media (max-width:600px){
    .search-result,.browse-result{font-size:.96rem; flex-direction:column;}
    .search-result img,.browse-result img{width:100%; max-height:180px;}
    .series-header img{width:64px;}
  }

  /* ====== Scrollbar (WebKit) ====== */
  *::-webkit-scrollbar{height:10px; width:10px;}
  *::-webkit-scrollbar-track{background:rgba(255,255,255,.06);}
  *::-webkit-scrollbar-thumb{background:linear-gradient(180deg, var(--accent), var(--accent-2)); border-radius:10px;}

  /* ====== Light theme kontrast ====== */
  body[data-theme="light"] .search-result .result-content div,
  body[data-theme="light"] .browse-result .result-content div{color:#34344a;}
  body[data-theme="light"] .series-info span,
  body[data-theme="light"] .series-seasons li{color:#515170;}
  /* === MOBILE: "Dostępne" kafle – układ poziomy z mini-posterem, tytułem, progresem i przyciskiem usuń pod paskiem === */
@media (max-width: 600px){
  /* Filmy (available-films) */
  #section-available .browse-result{
    flex-direction: row !important;
    align-items: center;
    gap: .75rem;
    padding: .8rem;
  }
  #section-available .browse-result img{
    width: 68px;
    height: 102px;
    aspect-ratio: 2 / 3;
    object-fit: cover;
    flex: 0 0 auto;
    border-radius: 10px;
    box-shadow: 0 6px 14px rgba(0,0,0,.35);
  }
  #section-available .browse-result .result-content{
    display: grid;
    grid-template-columns: 1fr auto;
    grid-template-areas:
      "title title"
      "progress progress"
      "delete time";
    align-items: center;
    gap: .45rem .6rem;
    width: 100%;
  }
  #section-available .browse-result .result-content > b{      /* tytuł */
    grid-area: title;
    font-size: 1rem;
    line-height: 1.25;
  }
  #section-available .browse-result .result-content .progress-bar{  /* progress */
    grid-area: progress;
    height: 10px;
    border-radius: 8px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  }
  #section-available .browse-result .result-content > small{  /* schowaj procent tekstowy by nie zaśmiecał */
    display: none;
  }
  /* Wew. wrapper z czasem i przyciskiem – przebuduj na siatkę: lewo=Usuń, prawo=Czas(+Reset) */
  #section-available .browse-result .result-content > div:last-child{
    grid-area: delete / 1 / span 1 / -1; /* zajmie cały wiersz, ale rozkładamy w nim 2 kolumny */
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: center;
    gap: .5rem;
    margin-top: .1rem !important;
  }
  /* przycisk "Usuń teraz" – po lewej, pełna szerokość, styl danger */
  #section-available .browse-result .result-content > div:last-child > /*button:last-of-type */{
    grid-column: 1;
    width: 100%;
    padding: .5rem .9rem;
    border-radius: 12px;
    background: linear-gradient(135deg, #ff3b30 0%, #ff9500 90%);
    box-shadow: 0 8px 22px rgba(255,59,48,.32);
    font-weight: 800;
  }
  /* blok z czasem i (opcjonalnie) resetem – po prawej */
  #section-available .browse-result .result-content > div:last-child > div:first-child{
    grid-column: 2;
    display: flex;
    align-items: center;
    gap: .4rem;
    justify-content: flex-end;
  }
  /* odchudź reset na mobile, żeby mieścił się koło czasu */
  #section-available .reset-btn{
    padding: .35rem .5rem;
    height: auto;
    font-size: .78rem;
    border-radius: 8px;
    box-shadow: 0 6px 16px rgba(39,174,96,.25);
  }

  /* Seriale (available-series) – miniaturka mniejsza, spójny odstęp */
  #section-available .series-card .series-header img{
    width: 60px !important;
    height: auto;
    border-radius: 10px;
  }
  /* "Usuń teraz" w serialach – taki sam styl danger i pełna szerokość pod progresem */
  #section-available .series-card .series-info > button{
    width: 100%;
    margin-top: .45rem;
    padding: .5rem .9rem;
    border-radius: 12px;
    background: linear-gradient(135deg, #ff3b30 0%, #ff9500 90%);
    box-shadow: 0 8px 22px rgba(255,59,48,.32);
    font-weight: 800;
  }
}

/* === Czas do usunięcia – elegancka "pigułka" (działa dla filmów i seriali) === */
#section-available [data-timer],
#section-available [data-timer-id]{
  display: inline-flex;
  align-items: center;
  gap: .35rem;
  padding: .25rem .55rem;
  border-radius: 999px;
  font-size: .86rem;
  font-weight: 800;
  letter-spacing: .2px;
  font-variant-numeric: tabular-nums;
  background: linear-gradient(135deg, rgba(0,240,255,.16), rgba(198,0,255,.16));
  color: var(--color-dark);
  border: 1px solid rgba(255,255,255,.12);
  box-shadow: 0 0 0 1px rgba(255,255,255,.06), var(--glow-soft);
}
body[data-theme="light"] #section-available [data-timer],
body[data-theme="light"] #section-available [data-timer-id]{
  color: var(--color-light);
  background: linear-gradient(135deg, rgba(0,0,0,.06), rgba(0,0,0,.03));
  border-color: rgba(0,0,0,.08);
}

/* === Dropdown (select) w trybie ciemnym – kontrastr i ciemna lista opcji === */
body[data-theme="dark"] select{
  -webkit-appearance: none;
  appearance: none;
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04)),
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%23cfd3ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat right .9rem center / 14px 14px;
  color: var(--color-dark);
  border: 1px solid rgba(255,255,255,.12);
  padding-right: 2.5rem; /* miejsce na strzałkę */
}
body[data-theme="dark"] select:focus{
  box-shadow: 0 0 0 2px rgba(198,0,255,.35), 0 0 0 6px rgba(0,240,255,.18), var(--shadow-card);
}
body[data-theme="dark"] select option{
  background-color: #151521;
  color: var(--color-dark);
}
/* Safari iOS – wymuszenie ciemnego stylu pop-upu gdzie to możliwe */
@supports (color-scheme: dark){
  body[data-theme="dark"] select{ color-scheme: dark; }
}

/* === MOBILE UPGRADE: lepszy układ gdy jest dostępny timer (countdown) === */
@media (max-width: 600px){
  /* 1) Jeśli kafel ma timer – ustaw wiersz z timerem NAD przyciskiem Usuń */
  @supports selector(:has(*)){
    #section-available .browse-result:has([data-timer]) .result-content{
      /* zostawiamy mini-poster po lewej, prawa kolumna w siatce */
      display: grid;
      grid-template-columns: 1fr;
      grid-template-areas:
        "title"
        "progress"
        "actions";
      gap: .5rem .6rem;
    }
    /* kontener z timerem+resetem oraz przyciskiem usuń */
    #section-available .browse-result:has([data-timer]) .result-content > div:last-child{
      grid-area: actions;
      display: grid !important;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto;    /* 1: timer+reset, 2: usuń */
      gap: .55rem;
      margin-top: .1rem !important;
    }
    /* rząd z timerem + reset pośrodku */
    #section-available .browse-result:has([data-timer]) .result-content > div:last-child > div:first-child{
      grid-row: 1; grid-column: 1;
      display: flex !important;
      align-items: center; justify-content: center;
      gap: .5rem;
      font-size: .9rem;
    }
    /* przycisk "Usuń teraz" – cały wiersz poniżej */
    #section-available .browse-result:has([data-timer]) .result-content > div:last-child > /*button:last-of-type */{
      grid-row: 2; grid-column: 1;
      width: 100%;
      padding: .55rem .9rem;
      border-radius: 12px;
      background: linear-gradient(135deg, #ff3b30 0%, #ff9500 92%);
      box-shadow: 0 8px 22px rgba(255,59,48,.28);
      font-weight: 800;
      font-size: .95rem;        /* żeby nie był "za wielki" */
    }
  }

  /* 2) Pasek postępu w "Dostępne" minimalnie cieńszy, żeby timer miał oddech */
  #section-available .progress-bar{ height: 10px; border-radius: 10px; }
}

/* === TIMER PILL: bardziej czytelny kapsel + subtelna poświata === */
#section-available [data-timer],
#section-available [data-timer-id]{
  display: inline-flex;
  align-items: center;
  gap: .4rem;
  padding: .28rem .62rem;
  border-radius: 999px;
  font-weight: 800;
  font-size: .9rem;
  letter-spacing: .2px;
  font-variant-numeric: tabular-nums;
  background:
    radial-gradient(60% 120% at 50% 0%, rgba(198,0,255,.18), transparent 65%),
    linear-gradient(180deg, rgba(26,26,40,.9), rgba(16,16,28,.9));
  color: var(--color-dark);
  border: 1px solid rgba(198,0,255,.35);
  box-shadow:
    0 0 0 2px rgba(0,0,0,.25) inset,
    0 0 16px rgba(102,56,255,.35),
    0 2px 10px rgba(0,0,0,.35);
}
body[data-theme="light"] #section-available [data-timer],
body[data-theme="light"] #section-available [data-timer-id]{
  color: var(--color-light);
  background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(245,247,251,.9));
  border-color: rgba(0,0,0,.08);
  box-shadow: 0 1px 6px rgba(0,0,0,.12) inset, 0 0 0 1px rgba(0,0,0,.06);
}

/* 3) Przyciski reset – kompakt w linii z timerem */
#section-available .reset-btn{
  padding: .38rem .6rem;
  font-size: .8rem;
  height: auto;
  border-radius: 10px;
  box-shadow: 0 6px 16px rgba(39,174,96,.22);
}

/* 4) Delikatny odstęp pod tytułem, by bar/ timer nie kleił się na mobile */
#section-available .browse-result .result-content > b{
  margin-bottom: .1rem;
}

/* === "Usuń teraz" — ten sam styl także na DESKTOP === */
#section-available .browse-result .result-content > div:last-child > /*button:last-of-type */,
#section-available .series-card .series-info > button{
  background: linear-gradient(135deg, #ff3b30 0%, #ff9500 92%) !important; /* danger */
  color: #fff !important;
  border: none;
  border-radius: 12px;
  padding: .55rem 1rem;
  font-weight: 800;
  font-size: .95rem;
  letter-spacing: .2px;
  box-shadow: 0 8px 22px rgba(255,59,48,.28);
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
}

/* hover/active – spójne zachowanie */
#section-available .browse-result .result-content > div:last-child > button:last-of-type:hover,
#section-available .series-card .series-info > button:hover{
  transform: translateY(-1px);
  filter: brightness(1.03);
  box-shadow: 0 10px 28px rgba(255,59,48,.36);
}
#section-available .browse-result .result-content > div:last-child > button:last-of-type:active,
#section-available .series-card .series-info > button:active{
  transform: translateY(0);
  filter: brightness(.98);
}

/* Na mobile dalej zostaje pełna szerokość (jak wcześniej) */
@media (max-width: 600px){
  #section-available .browse-result .result-content > div:last-child > button:last-of-type,
  #section-available .series-card .series-info > button{ width: 100%; }
}

/* === TABS BEZ PRZEWIJANIA — DESKTOP + MOBILE === */
/* Sekcja SZUKAJ: 3 zakładki (Filmy, Filmy+, Seriale) */
#search-tabs{
  overflow-x: hidden !important;         /* wyłącz przewijanie */
  justify-content: center;               /* wyśrodkuj */
  gap: .5rem;
}
#search-tabs .search-tab{
  min-width: auto !important;            /* zdejmij minimalną szerokość */
  flex: 1 1 33.333% !important;          /* 3 równe przyciski w wierszu */
  max-width: none;
  white-space: nowrap;                    /* bez łamań */
  padding: .7rem 1rem;
}

/* Sekcja DOSTĘPNE: 2 zakładki (Filmy/Seriale) */
#available-tabs{
  overflow-x: hidden !important;
  justify-content: center;
  gap: .5rem;
}
#available-tabs .search-tab{
  min-width: auto !important;
  flex: 1 1 50% !important;              /* 2 równe przyciski */
  max-width: none;
  white-space: nowrap;
  padding: .7rem 1rem;
}

/* Mobile tightening (żeby zawsze się mieściły) */
@media (max-width: 420px){
  #search-tabs .search-tab,
  #available-tabs .search-tab{
    padding: .6rem .6rem;
    font-size: .95rem;
  }
}
@media (max-width: 360px){
  #search-tabs .search-tab,
  #available-tabs .search-tab{
    padding: .55rem .45rem;
    font-size: .9rem;
    letter-spacing: .1px;
  }
}

/* === "Resetuj" w sekcji DOSTĘPNE — nowy, spójny styl (desktop+mobile) === */
#section-available .reset-btn{
  background: linear-gradient(135deg, #27ae60 0%, #36d17c 90%) !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 12px;
  padding: .45rem .8rem;
  font-weight: 800;
  font-size: .9rem;
  letter-spacing: .2px;
  box-shadow: 0 8px 20px rgba(39,174,96,.26), 0 0 0 1px rgba(255,255,255,.04) inset;
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
}
#section-available .reset-btn:hover{
  transform: translateY(-1px);
  filter: brightness(1.04);
  box-shadow: 0 10px 26px rgba(39,174,96,.34);
}
#section-available .reset-btn:active{
  transform: translateY(0);
  filter: brightness(.98);
}

/* Mobile kompakt obok timera */
@media (max-width: 600px){
  #section-available .reset-btn{
    padding: .38rem .6rem;
    font-size: .82rem;
    border-radius: 10px;
  }
}


/* === SZUKAJ: długość pola "Szukaj tytułu" (desktop + mobile) === */
#section-search #search-query{
  width: 100%;
  max-width: 560px;         /* DESKTOP limit szerokości */
  margin: .5rem auto 0;     /* wyśrodkuj */
  display: block;
}
@media (min-width: 1200px){
  #section-search #search-query{ max-width: 640px; }  /* na bardzo szerokich */
}
@media (max-width: 600px){
  #section-search #search-query{
    max-width: 100%;        /* MOBILE pełna szerokość */
    margin-top: .4rem;
  }
}
#section-search #search-query::placeholder{
  opacity: .9;
}
body[data-theme="light"] #section-search #search-query::placeholder{
  color:#6b6b80;
}

/* === MOBILE (jasny tryb): spójny styl wszystkich <select> jak w ciemnym === */
body[data-theme="light"] select{
  -webkit-appearance: none;
  appearance: none;
  background:
    linear-gradient(180deg, rgba(0,0,0,.04), rgba(0,0,0,.02)),
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%23515170' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat right .9rem center / 14px 14px;
  color: var(--color-light);
  border: 1px solid rgba(0,0,0,.10);
  padding-right: 2.5rem;            /* miejsce na strzałkę */
  box-shadow: inset 0 1px 0 rgba(255,255,255,.75), var(--shadow-card);
  border-radius: var(--radius-lg);
}
body[data-theme="light"] select:focus{
  box-shadow: 0 0 0 2px rgba(198,0,255,.28),
              0 0 0 6px rgba(0,240,255,.14),
              var(--shadow-card);
}
body[data-theme="light"] select option{
  background-color: #ffffff;
  color: var(--color-light);
  /* przezroczystość subtelna jak w ciemnym */
  background-image: linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.00));
  border: none;
}
/* Wymuszenie jasnego pop-upu (Safari/iOS) */
@supports (color-scheme: light){
  body[data-theme="light"] select{ color-scheme: light; }
}

/* MOBILE drobna kompaktowość dla selectów w jasnym trybie */
@media (max-width: 600px){
  body[data-theme="light"] select{
    padding: .85rem 1rem;
    padding-right: 2.5rem;
    font-size: 1rem;
  }
}


/* === SZUKAJ: skróć pole "Szukaj tytułu" i nadpisz globalne width:100% === */
#section-search input#search-query{
  width: clamp(240px, 46ch, 460px) !important; /* krótsze na desktopie */
  display: block;
  margin: .5rem auto .75rem;                  /* wyśrodkuj */
}

/* Bardzo szerokie ekrany – trzymaj stałą, zgrabną szerokość */
@media (min-width: 1280px){
  #section-search input#search-query{ width: 460px !important; }
}

/* Mobile – prawie pełna szerokość, ale z marginesami bocznymi */
@media (max-width: 600px){
  #section-search input#search-query{
    width: clamp(220px, 88vw, 360px) !important;
  }
}


/* Jeszcze krótsze pole "Szukaj tytułu" na mobilach */
@media (max-width: 600px){
  #section-search input#search-query{
    width: clamp(150px, 72vw, 280px) !important;
    margin-left: auto; margin-right: auto;
    font-size: .95rem;
  }
}
@media (max-width: 420px){
  #section-search input#search-query{
    width: clamp(150px, 68vw, 240px) !important;
  }
}
@media (max-width: 360px){
  #section-search input#search-query{
    width: clamp(140px, 64vw, 220px) !important;
  }
}


/* USUŃ RAMKI POD PRZYCISKAMI (desktop + mobile) */
/* Wyłącz tło, ramkę, blur i cień kontenera zakładek */
.search-tabs,
#search-tabs,
#available-tabs,
#torrent-tabs{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  padding: 0 !important;         /* bez wewnętrznej „ramki” */
  border-radius: 0 !important;   /* dla pewności – zero zaokrąglenia kontenera */
}

/* W trybie jasnym również bez ramki */
body[data-theme="light"] .search-tabs,
body[data-theme="light"] #search-tabs,
body[data-theme="light"] #available-tabs,
body[data-theme="light"] #torrent-tabs{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}


/* HARD RESET: zero „ramek/hal” pod zakładkami (desktop + mobile) */
.search-tabs,
#search-tabs,
#available-tabs,
#torrent-tabs{
  background: transparent !important;
  border: 0 !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  outline: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
}
.search-tabs::before,
.search-tabs::after,
#search-tabs::before,
#search-tabs::after,
#available-tabs::before,
#available-tabs::after,
#torrent-tabs::before,
#torrent-tabs::after{
  content: none !important;
  display: none !important;
}

/* same przyciski – brak tła/obwódek dla NIEaktywnych */
#search-tabs .search-tab,
#available-tabs .search-tab,
#torrent-tabs .search-tab{
  background: transparent !important;
  border: 0 !important;
  box-shadow: none !important;
}

/* aktywna zakładka – zostaw gradient pigułkę, usuń zewnętrzną poświatę (halo) */
#search-tabs .search-tab.active,
#available-tabs .search-tab.active,
#torrent-tabs .search-tab.active{
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 80%) !important;
  color: #fff !important;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06) !important; /* bez rozlanej poświaty */
}
#search-tabs .search-tab.active::after,
#available-tabs .search-tab.active::after,
#torrent-tabs .search-tab.active::after{
  display: none !important; /* wyłącz „sheen”, jeśli robi otoczkę */
}
/* ====== Modal potwierdzenia usuwania ====== */
#confirm-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s ease;
}

#confirm-modal.show {
  opacity: 1;
  pointer-events: all;
}

#confirm-modal.hidden {
  display: none;
}

/* Okno */
#confirm-modal .modal-content {
  background: #222; /* ciemny motyw domyślnie */
  color: #eee;
  padding: 1.5rem 2rem;
  border-radius: 12px;
  max-width: 400px;
  width: 90%;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
  text-align: center;
  animation: scaleIn 0.25s ease;
}

/* Treść wiadomości */
#confirm-message {
  margin-bottom: 1rem;
  font-size: 1.1rem;
  line-height: 1.4;
  font-weight: 500;
}

/* Pogrubiony tytuł */
#confirm-message b {
  font-weight: 700;
  color: #fff;
}

/* Przyciski */
#confirm-yes,
#confirm-no {
  margin: 0.4rem;
  padding: 0.6rem 1.4rem;
  font-size: 1rem;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  transition: background 0.2s ease, transform 0.1s ease;
}

#confirm-yes {
  background: #e74c3c;
  color: #fff;
}
#confirm-yes:hover {
  background: #c0392b;
  transform: scale(1.05);
}

#confirm-no {
  background: #555;
  color: #fff;
}
#confirm-no:hover {
  background: #666;
  transform: scale(1.05);
}

/* ====== Jasny tryb ====== */
#confirm-modal.light .modal-content {
  background: #fff;
  color: #222;
}

#confirm-modal.light #confirm-message b {
  color: #000;
}

#confirm-modal.light #confirm-yes {
  background: #e74c3c;
  color: #fff;
}
#confirm-modal.light #confirm-no {
  background: #ddd;
  color: #222;
}
#confirm-modal.light #confirm-no:hover {
  background: #ccc;
}

/* Animacja */
@keyframes scaleIn {
  from { transform: scale(0.9); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

/* ====== Mobile ====== */
@media (max-width: 480px) {
  #confirm-modal .modal-content {
    max-width: 90%;
    padding: 1rem;
  }
  #confirm-yes,
  #confirm-no {
    display: block;
    width: 100%;
    margin: 0.5rem 0;
    font-size: 1rem;
  }
}

button[onclick^="confirmDelete("],
.btn-danger {
  background: linear-gradient(135deg, #ff3b30 0%, #ff9500 92%) !important;
  color: #fff !important;
  border: none;
  border-radius: 12px;
  padding: .55rem 1rem;
  font-weight: 800;
  font-size: .95rem;
  letter-spacing: .2px;
  box-shadow: 0 8px 22px rgba(255,59,48,.28);
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
}
button[onclick^="confirmDelete("]:hover,
.btn-danger:hover { transform: translateY(-1px); filter: brightness(1.03); box-shadow: 0 10px 28px rgba(255,59,48,.36); }
button[onclick^="confirmDelete("]:active,
.btn-danger:active { transform: translateY(0); filter: brightness(.98); }

/* (opcjonalnie) na mobile dalej pełna szerokość */
@media (max-width: 600px){
  button[onclick^="confirmDelete("] { width: 100%; }
}

.delete-btn, .btn-danger { /* ten sam blok jak powyżej */ }
/* MOBILE: % obejrzane POD TYTUŁEM (nad paskiem) */
@media (max-width: 600px){
  /* standardowy układ kart filmu */
  #section-available .browse-result .result-content{
    display: grid !important;
    grid-template-columns: 1fr auto; /* jak u Ciebie */
    grid-template-areas:
      "title title"
      "percent percent"   /* <-- NOWY rząd */
      "progress progress"
      "actions actions";
    gap: .45rem .6rem;
  }

  /* przypisanie obszarów */
  #section-available .browse-result .result-content > b{        /* tytuł */
    grid-area: title !important;
  }
  #section-available .browse-result .result-content > .progress-bar{
    grid-area: progress !important;
  }
  #section-available .browse-result .result-content > div:last-child{
    grid-area: actions !important;
  }

  /* SAM % – pokaż go i ustaw w nowym wierszu */
  #section-available .browse-result .result-content > small{
    grid-area: percent !important;
    display: inline-block !important;   /* nadpisuje wcześniejsze "display:none" */
    margin: .1rem 0 .2rem;
    opacity: .9;
    font-size: .9rem;
    justify-self: start;                 /* lub center jeśli wolisz wyśrodkować */
  }

  /* wariant z timerem – też wstaw "percent" pod tytułem */
  @supports selector(:has(*)){
    #section-available .browse-result:has([data-timer]) .result-content{
      grid-template-columns: 1fr !important;
      grid-template-areas:
        "title"
        "percent"        /* <-- NOWY rząd */
        "progress"
        "actions";
    }
  }
}



/* Mobile: karty lżejsze (bez blur), przeglądarka renderuje tylko widoczne */
@media (max-width: 600px){
  .browse-result,
  .series-card{
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    box-shadow: 0 6px 14px rgba(0,0,0,.25) !important; /* lżejszy cień */
    content-visibility: auto;           /* maluj tylko to, co w viewport */
    contain-intrinsic-size: 220px;      /* zapobiega skokom layoutu */
  }
}

@media (max-width: 600px) {
  #section-available .browse-result img {
    width: 88px;          /* trochę większy */
    aspect-ratio: 2 / 3;  /* zachowaj proporcje */
    height: auto;         /* wyliczy się automatycznie */
    object-fit: cover;
    border-radius: 12px;
    box-shadow: 0 6px 14px rgba(0, 0, 0, .35);
  }
}

/* Mobile: bardzo małe przyciski CAST i Usuń */
@media (max-width: 600px){
  #section-available .browse-result .result-content > div:last-child button{
    padding: .25rem .45rem;   /* bardzo małe wnętrze */
    font-size: .7rem;         /* mniejszy tekst */
    line-height: 1.1;
    border-radius: 8px;       /* mniejsze zaokrąglenie */
    min-height: 32px;         /* zachowana klikalność */
  }

  /* Ikony też minimalne */
  #section-available .browse-result .result-content > div:last-child button svg{
    width: 14px;
    height: 14px;
    margin-right: .2rem;
  }
}

/* Mobile: ściśnięte karty filmów */
@media (max-width: 600px){
  #section-available .browse-result{
    padding: .6rem .7rem;       /* mniejszy padding w karcie */
  }

  #section-available .browse-result img{
    width: 82px;                /* lekko mniejszy poster */
    aspect-ratio: 2 / 3;
    height: auto;
    margin: 0;                  /* usuń dodatkowy odstęp */
  }

  #section-available .browse-result .result-content{
    gap: .3rem .5rem;            /* ciaśniejsze przerwy w gridzie */
  }

  #section-available .browse-result .result-content > b{
    margin-bottom: .1rem;        /* tytuł bliżej reszty */
  }

  #section-available .browse-result .result-content > small{
    margin: .05rem 0 .15rem;     /* mniej przestrzeni wokół % obejrzane */
  }

  #section-available .browse-result .progress-bar{
    margin: .1rem 0;             /* pasek bliżej innych elementów */
  }

  #section-available .browse-result .result-content > div:last-child{
    margin-top: .2rem;           /* przyciski bliżej paska */
  }
}

/* ===== GENRES ===== */

/* Desktop: w prawym górnym rogu */
.browse-result{ position: relative; }
.genre-badges{
  position: absolute;
  top: 10px; right: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: .35rem;
  justify-content: flex-end;
  max-width: 52%;
  pointer-events: none;
  z-index: 2;
}
.genre-badge{
  pointer-events: auto;
  padding: .25rem .55rem;
  border-radius: 999px;
  font-weight: 700;
  font-size: .7rem;
  line-height: 1;
  color: #fff;
  border: 1px solid rgba(255,255,255,.16);
  box-shadow: 0 1px 4px rgba(0,0,0,.25);
  white-space: nowrap;
  user-select: none;
}
body[data-theme="light"] .genre-badge{
  border-color: rgba(0,0,0,.12);
  box-shadow: 0 1px 3px rgba(0,0,0,.2);
}
.genre-badge.is-generic{
  background: linear-gradient(135deg,#6a6aff,#39d1ff);
}
@media (hover:hover){
  .genre-badge:hover{
    filter: brightness(1.1);
    transform: translateY(-1px);
    transition: filter .2s, transform .15s;
  }
}

/* Mobile: malutkie kapsułki w jednej linii pod progress barem */
@media (max-width:600px){
  .genre-badges{
    position: static;
    margin-top: .3rem;
    max-width: 100%;
    justify-content: flex-start;
    gap: .25rem;
  }
  .genre-badge{
    font-size: .55rem;         /* naprawdę małe */
    padding: .15rem .35rem;
    border-radius: 999px;
    font-weight: 600;
  }
}
details.series-card{ position: relative; }
/* === SERIALE: badge pod paskiem progresu (zawsze) === */
details.series-card { position: relative; }  /* tylko porządek */

.series-card .genre-badges{
  position: static !important;   /* nadpisuje wersję desktopową */
  margin-top: .45rem;
  display: flex;
  flex-wrap: wrap;
  gap: .35rem;
  justify-content: flex-start;
  max-width: 100%;
  pointer-events: auto;
}

.series-card .genre-badge{
  padding: .3rem .6rem;
  border-radius: 999px;
  font-weight: 700;
  font-size: .72rem;
  line-height: 1;
  color: #fff;
  border: 1px solid rgba(255,255,255,.16);
  box-shadow: 0 1px 4px rgba(0,0,0,.25);
  white-space: nowrap;
}

/* Na bardzo małych ekranach – jeszcze ciaśniej */
@media (max-width: 600px){
  .series-card .genre-badge{
    font-size: .6rem;
    padding: .18rem .42rem;
  }
}

/* ===== RANDOMIZER: floating action button (FAB) ===== */
#rand-fab{
  position: fixed;
  left: 14px;
  bottom: calc(84px + env(safe-area-inset-bottom)); /* nad dolnym navem */
  width: 60px; height: 60px;
  border-radius: 999px;
  display: grid; place-items: center;
  font-size: 1.45rem;
  color: #fff;
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 80%);
  box-shadow: 0 12px 28px rgba(0,0,0,.35), var(--glow-strong);
  border: var(--border-glass);
  cursor: pointer;
  z-index: 1003;
}
#rand-fab:active{ transform: translateY(1px) scale(.985); }

@media (max-width: 600px){
  #rand-fab{ width: 54px; height: 54px; font-size: 1.2rem; left: 10px; bottom: calc(78px + env(safe-area-inset-bottom)); }
}

/* ===== RANDOMIZER: modal wyboru gatunków ===== */
#rand-modal,
#rand-result{
  position: fixed; inset: 0;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.55); backdrop-filter: blur(6px);
  z-index: 1004;
}
#rand-modal.show, #rand-result.show{ display: flex; }

.rand-card{
  width: min(92vw, 520px);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  color: var(--color-dark);
  border: var(--border-glass);
  box-shadow: var(--shadow-card), var(--glow-soft);
  border-radius: 18px; padding: 1rem;
}
body[data-theme="light"] .rand-card{
  background: var(--card-bg-light); color: var(--color-light);
}

.rand-title{ font-weight: 900; font-size: 1.2rem; margin: .25rem 0 .6rem; }
.rand-actions{ display:flex; gap:.6rem; justify-content:flex-end; margin-top:.8rem; }

/* lista gatunków */
#rand-genres{
  max-height: 54vh; overflow:auto;
  display:grid; grid-template-columns: 1fr 1fr; gap:.4rem .8rem;
  padding-right:.2rem;
}
@media (max-width: 520px){ #rand-genres{ grid-template-columns: 1fr; } }

.rand-row{
  display:flex; align-items:center; gap:.55rem;
  padding:.45rem .55rem; border-radius:12px;
  border: var(--border-glass);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
}
.rand-row input{ width:18px; height:18px; }
.rand-row label{ flex:1; font-weight:700; }

/* przycisk „Losuj” */
.rand-primary{
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 80%);
  color:#fff; font-weight:900; border:none;
  padding:.7rem 1.1rem; border-radius:12px;
  box-shadow: var(--glow-strong);
}

/* ===== RANDOMIZER: modal wyniku ===== */
.rand-result-inner{
  width: min(92vw, 520px);
  display:flex; flex-direction:column; align-items:center; text-align:center;
}
.rand-poster-wrap{
  position: relative;
  padding: 14px; border-radius: 18px; margin:.2rem 0 .6rem;
  background: radial-gradient(120% 120% at 50% 10%, rgba(198,0,255,.18), rgba(0,0,0,.0)),
              linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  border: var(--border-glass);
  box-shadow: var(--glow-soft), 0 12px 32px rgba(0,0,0,.35);
  animation: popIn .28s ease;
}
.rand-poster-wrap::after{
  content:""; position:absolute; inset:0; border-radius:18px;
  background: linear-gradient(120deg, rgba(255,255,255,.25), rgba(255,255,255,0) 40%);
  mix-blend-mode: overlay; pointer-events:none;
}
.rand-poster{
  width: 220px; aspect-ratio: 2/3; object-fit: cover;
  display:block; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.35);
}
@keyframes popIn{ from{ transform:scale(.96); opacity:0 } to{ transform:scale(1); opacity:1 } }

.rand-title-film{
  font-weight: 900; font-size: 1.15rem; margin:.4rem 0 .8rem;
}

.rand-cta{ display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center; }
.rand-cta button{
  padding:.65rem 1.1rem; border-radius:12px; font-weight:800; border:none;
}
.rand-cta .cast{ background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#fff; box-shadow: var(--glow-strong); }
.rand-cta .close{ background: linear-gradient(135deg, #555, #333); color:#fff; }
body[data-theme="light"] .rand-cta .close{ background: linear-gradient(135deg, #e6e6e6, #cccccc); color:#000; }

/* ===== RANDOMIZER: stan „rolling” (animacja losowania) ===== */
#rand-result .rand-cta{ opacity:1; transition:opacity .2s ease; }
#rand-result.rolling .rand-cta{ opacity:0; pointer-events:none; }

#rand-rolling-hint{
  margin-top:.25rem;
  font-weight:800; font-size:.95rem; opacity:.9;
}

/* subtelna animacja „shake/tilt” plakatu podczas losowania */
@keyframes randSpin {
  0%   { transform: rotate(-2deg) scale(0.98); filter: blur(0px); }
  25%  { transform: rotate(2deg)  scale(1.00); filter: blur(.4px); }
  50%  { transform: rotate(-1.5deg) scale(0.99); filter: blur(.2px); }
  75%  { transform: rotate(1.5deg) scale(1.00); filter: blur(.4px); }
  100% { transform: rotate(0deg)  scale(1.00); filter: blur(0px); }
}
#rand-result.rolling .rand-poster-wrap{ animation: popIn .28s ease, randSpin .6s ease-in-out infinite; }

/* awaryjne skalowanie na bardzo małych ekranach */
@media (max-width: 360px){
  .rand-poster{ width: 190px; }
}

/* domyślne położenie */
#rand-fab{
  bottom: calc(84px + env(safe-area-inset-bottom));
  transition: bottom .3s ease;
}

/* gdy player jest widoczny */
body.cast-active #rand-fab{
  bottom: calc(200px + env(safe-area-inset-bottom)); /* +~100px dla paska */
}

/* === L I V E S E A R C H  (wysuwany panel) === */
/* FAB: wyszukiwarka 🔍 */
#live-toggle{
  position: fixed;
  right: 14px;
  /* ustaw bazę tak, żeby był nad kostką */
  --lift-base: calc(150px + env(safe-area-inset-bottom));
  bottom: var(--lift-base);
  width: 54px; height: 54px; border-radius: 999px;
  display: grid; place-items: center;
  z-index: 1003;
  background: linear-gradient(135deg, #36d1dc, #5b86e5);
  color:#fff; font-size: 1.15rem; border: var(--border-glass);
  box-shadow: 0 12px 28px rgba(0,0,0,.35), var(--glow-strong);
  cursor: pointer; transition: bottom .3s ease, transform .12s ease;
}
#live-toggle:active{ transform: translateY(1px) scale(.985); }

/* unoszenie nad castem */
body.cast-active #live-toggle{
  bottom: calc(var(--lift-base) + var(--cast-ui-height) + env(safe-area-inset-bottom));
}


#live-overlay{
  position: fixed; inset: 0; background: rgba(0,0,0,.45);
  backdrop-filter: blur(4px); display: none; z-index: 1003;
}
#live-overlay.show{ display:block; }

#live-panel{
  position: fixed; top: 0; right: 0; height: 100svh; width: min(92vw, 380px);
  transform: translateX(100%); transition: transform .28s ease;
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  color: var(--color-dark);
  border-left: var(--border-glass); box-shadow: -10px 0 26px rgba(0,0,0,.35);
  z-index: 1004; display: flex; flex-direction: column;
}
body[data-theme="light"] #live-panel{ background: var(--card-bg-light); color: var(--color-light); }

#live-panel.show{ transform: translateX(0); }

.live-head{
  display:flex; align-items:center; justify-content:space-between; gap:.6rem;
  padding: .9rem; border-bottom: var(--border-glass);
}
.live-head b{ font-size:1.05rem; }

.live-body{ padding:.9rem; overflow:auto; }

#live-query{
  width:100%; padding:.8rem 1rem; border-radius: 12px; border: 1px solid rgba(255,255,255,.14);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
  color:inherit; margin-bottom:.7rem; font-size:1rem;
}
body[data-theme="light"] #live-query{ border-color: rgba(0,0,0,.12); }

.live-actions{
  display:flex; align-items:center; justify-content:space-between; gap:.6rem; margin:.4rem 0 .6rem;
}

#live-genres{
  display:grid; grid-template-columns: 1fr 1fr; gap:.45rem .7rem;
  max-height: 54vh; overflow:auto; padding-right: .2rem;
}
@media (max-width: 520px){ #live-genres{ grid-template-columns: 1fr; } }

.live-row{
  display:flex; align-items:center; gap:.55rem; padding:.45rem .55rem; border-radius:12px;
  border: var(--border-glass);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
}
.live-row input{ width:18px; height:18px; }
.live-row label{ flex:1; font-weight:700; }

.live-foot{
  padding: .8rem .9rem; border-top: var(--border-glass);
  font-size:.92rem; opacity:.9; display:flex; justify-content:space-between; gap:.6rem;
}

.hidden-live{ display:none !important; }
/* ===== Uniwersalne unoszenie FAB-ów nad paskiem CAST ===== */
:root{
  /* wysokość paska CAST (wraz z oddechem); dopasuj w razie potrzeby */
  --cast-ui-height: 110px;
}

/* Elementy, które mają się unosić: ustawiają własną bazę dołu przez --lift-base */
.lift-with-cast{
  position: fixed;                 /* zakładamy, że FAB-y są fixed */
  transition: bottom .3s ease;
  bottom: var(--lift-base, 84px);  /* domyślna baza jeśli nie podasz */
}

/* gdy CAST aktywny – dołóż wysokość playera */
body.cast-active .lift-with-cast{
  bottom: calc(var(--lift-base, 84px) + var(--cast-ui-height) + env(safe-area-inset-bottom));
}


</style>


</head>

<body data-theme="dark">

  <div class="container">
    <div class="logo-container">
      <div class="theme-toggle-container lift-with-cast" style="--lift-base: 7rem;">
  <label class="switch-label small">
    <input type="checkbox" id="theme-toggle" class="switch-input">
    <span class="switch-slider"></span>
  </label>
</div>

  <img src="static/logo.png" alt="PiotrFlix logo" class="logo-img">

</div>


    <!-- Torrenty -->
    <div id="section-torrents" class="section active">
      <label for="sort">Sortuj:</label>
      <select id="sort" onchange="loadTorrents()">
        <option value="name">Nazwa</option>
        <option value="progress">Postęp</option>
        <option value="state">Stan</option>
      </select>
      <label for="global-speed-limit">🌐 Ogranicz prędkość pobierania:</label>
<select id="global-speed-limit">
  <option value="0">Unlimited</option>
  <option value="1">1 MB/s</option>
  <option value="2">2 MB/s</option>
  <option value="5">5 MB/s</option>
  <option value="10">10 MB/s</option>
  <option value="15">15 MB/s</option>
</select>
      <!-- mały status pod selectem -->
<div id="global-speed-feedback" style="margin-top:6px;font-size:.9rem;color:#444;"></div>


      <div id="summary" style="margin: 1rem 0; font-weight: bold;"></div>
      <div class="search-tabs" id="torrent-tabs" style="margin-bottom: 1rem;">
  <button class="search-tab active" data-torrent-tab="active">⚡ AKTYWNE</button>
  <button class="search-tab" data-torrent-tab="history">📁 HISTORIA</button>
</div>
      <div id="torrents"></div>
    </div>

<!-- Dostępne -->
<div id="section-available" class="section">
  <div class="search-tabs" id="available-tabs" style="margin-bottom: 1rem;">
    <button class="search-tab active" data-available-tab="films">🎬 Dostępne filmy</button>
    <button class="search-tab" data-available-tab="series">📺 Dostępne seriale</button>
  </div>

  <!-- Loader -->
  <div id="loading-message" style="text-align:center; margin: 20px; display: none;">
    <strong>⏳ Proszę czekać, trwa ładowanie...</strong>
  </div>

  <!-- Filmy i seriale -->
  <div id="available-films" class="available-tab-content"></div>
  <div id="available-series" class="available-tab-content">
  <div id="plex-series"></div>
</div>
</div>


<!-- Szukaj -->
<div id="section-search" class="section">
  <div id="search-tabs" class="search-tabs" style="margin-bottom: 1rem;">
  <button data-type="movies" class="search-tab active">🎬 Filmy</button>
    <button data-type="premium" class="search-tab">💎 Filmy+</button>
  <button data-type="series" class="search-tab">📺 Seriale</button>
</div>

  <input type="text" id="search-query" placeholder="Szukaj tytułu" />

  <label for="quality">Jakość:</label>
  <select id="quality">
    <option value="">Wszystkie</option>
    <option value="720p">720p</option>
    <option value="1080p" selected>1080p</option>
    <option value="2160p">2160p</option>
  </select>

  <button id="search-button">🔍 Szukaj</button>

  <div id="search-status"></div>
  <div id="search-results"></div>
</div>


    <!-- Przeglądaj -->
    <div id="section-browse" class="section">
      <div id="browse-filters">
  <div class="filter-group">
    <label for="browse-quality">🎥 Jakość:</label>
    <select id="browse-quality">
      <option value="0">All</option>
      <option value="480p">480p</option>
      <option value="720p">720p</option>
      <option value="1080p">1080p</option>
      <option value="1080p.x265">1080p.x265</option>
      <option value="2160p">2160p</option>
      <option value="3D">3D</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="browse-genre">🎭 Gatunek:</label>
    <select id="browse-genre">
      <option value="0">All</option>
      <option value="Action">Action</option>
      <option value="Adventure">Adventure</option>
      <option value="Animation">Animation</option>
      <option value="Biography">Biography</option>
      <option value="Comedy">Comedy</option>
      <option value="Crime">Crime</option>
      <option value="Documentary">Documentary</option>
      <option value="Drama">Drama</option>
      <option value="Family">Family</option>
      <option value="Fantasy">Fantasy</option>
      <option value="Film-Noir">Film-Noir</option>
      <option value="Game-Show">Game-Show</option>
      <option value="History">History</option>
      <option value="Horror">Horror</option>
      <option value="Music">Music</option>
      <option value="Musical">Musical</option>
      <option value="Mystery">Mystery</option>
      <option value="News">News</option>
      <option value="Reality-TV">Reality-TV</option>
      <option value="Romance">Romance</option>
      <option value="Sci-Fi">Sci-Fi</option>
      <option value="Sport">Sport</option>
      <option value="Talk-Show">Talk-Show</option>
      <option value="Thriller">Thriller</option>
      <option value="War">War</option>
      <option value="Western">Western</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="browse-rating">⭐ Ocena IMDb:</label>
    <select id="browse-rating">
      <option value="0">All</option>
      <option value="9">9+</option>
      <option value="8">8+</option>
      <option value="7">7+</option>
      <option value="6">6+</option>
      <option value="5">5+</option>
      <option value="4">4+</option>
      <option value="3">3+</option>
      <option value="2">2+</option>
      <option value="1">1+</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="browse-year">📅 Rok produkcji:</label>
    <select id="browse-year">
      <option value="0">All</option>
      <option value="2025">2025</option>
      <option value="2024">2024</option>
      <option value="2020-now">2020-now</option>
      <option value="2010-now">2010-now</option>
      <option value="2010-2019">2010-2019</option>
      <option value="2000-2009">2000-2009</option>
      <option value="1990-1999">1990-1999</option>
      <option value="1980-1989">1980-1989</option>
      <option value="1970-1979">1970-1979</option>
      <option value="1950-1969">1950-1969</option>
      <option value="1900-1949">1900-1949</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="browse-order">🔃 Sortuj wg:</label>
    <select id="browse-order">
      <option value="latest">Latest</option>
      <option value="oldest">Oldest</option>
      <option value="featured">Featured</option>
      <option value="seeds">Seeds</option>
      <option value="peers">Peers</option>
      <option value="year">Year</option>
      <option value="rating">IMDb Rating</option>
      <option value="likes">YTS Likes</option>
      <option value="rt_audience">RT Audience</option>
      <option value="alphabetical">Alphabetical</option>
      <option value="downloads">Downloads</option>
    </select>
  </div>

      </div>
      <button onclick="browseMovies()">📂 Przeglądaj</button>
      <div id="browse-status"></div>
      <div id="browse-results"></div>
      <div id="browse-pagination"></div>
    </div>
  </div>

  <!-- Nawigacja -->
<!-- ====== NAWIGACJA (nowa, izolowana) ====== -->
<nav class="nawigacja" id="nawigacja" role="tablist" aria-label="Główna nawigacja">
  <button class="nawigacja__btn" data-section="torrents" role="tab" aria-controls="section-torrents" aria-selected="false">
    <!-- secure-download -->
    <svg class="nawigacja__ico" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M12 3a4 4 0 0 0-4 4v2H6a1 1 0 0 0-1 1v1h14V10a1 1 0 0 0-1-1h-2V7a4 4 0 0 0-4-4Zm-1 11.59V9h2v5.59l1.29-1.3 1.42 1.42-3.7 3.7a1 1 0 0 1-1.42 0l-3.7-3.7 1.42-1.42L11 14.59ZM5 20a2 2 0 0 1-2-2v-4h2v4h14v-4h2v4a2 2 0 0 1-2 2H5z"/>
    </svg>
    <span class="nawigacja__label">Torrenty</span>
  </button>

  <button class="nawigacja__btn" data-section="search" role="tab" aria-controls="section-search" aria-selected="false">
    <!-- search -->
    <svg class="nawigacja__ico" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M10 4a6 6 0 1 1 0 12A6 6 0 0 1 10 4m0-2a8 8 0 1 0 5.29 14.02l4.84 4.85 1.41-1.42-4.83-4.84A8 8 0 0 0 10 2z"/>
    </svg>
    <span class="nawigacja__label">Szukaj</span>
  </button>

  <button class="nawigacja__btn" data-section="browse" role="tab" aria-controls="section-browse" aria-selected="false">
    <!-- folder-search -->
    <svg class="nawigacja__ico" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M10 4l2 2h6a2 2 0 0 1 2 2v2H4V6a2 2 0 0 1 2-2h4zm-6 8h20v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-6zm9 1.5a3.5 3.5 0 1 0 2.45 6l1.78 1.77 1.06-1.06-1.77-1.78A3.5 3.5 0 0 0 13 13.5zm0 2a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/>
    </svg>
    <span class="nawigacja__label">Przeglądaj</span>
  </button>

  <button class="nawigacja__btn" data-section="available" role="tab" aria-controls="section-available" aria-selected="false">
    <!-- film -->
    <svg class="nawigacja__ico" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M4 4h3v3H4V4Zm0 6h3v3H4v-3Zm0 6h3v3H4v-3ZM9 4h10a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H9V4Zm-5 0a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h1v-2H4V6h1V4H4Zm11 0v3h3V4h-3Zm0 6v3h3v-3h-3Zm0 6v3h3v-3h-3Z"/>
    </svg>
    <span class="nawigacja__label">Dostępne</span>
  </button>
</nav>

  <div id="quality-modal">
    <div class="modal-content">
      <h3>Wybierz jakość</h3>
      <select id="modal-quality">
        <option value="2160p">2160p</option>
        <option value="1080p" selected>1080p</option>
        <option value="720p">720p</option>
      </select>
      <button onclick="confirmQuality()">🎯 Pobierz</button>
      <button onclick="closeModal()" style="margin-top:0.5rem;">❌ Anuluj</button>
    </div>
  </div>

<!-- CAST: modal wyboru urządzenia -->
<div id="cast-modal">
  <div class="modal-inner">
    <h3 style="margin:.2rem 0 .6rem;">Wybierz urządzenie do odtwarzania</h3>
    <div id="cast-devices">Ładowanie…</div>
    <div class="actions">
      <button id="cast-confirm">▶️ Odtwarzaj tutaj</button>
      <button id="cast-cancel" onclick="closeCastModal()">❌ Anuluj</button>
    </div>
  </div>
</div>

<!-- CAST: mini pasek sterowania (mini-player) -->
<div id="cast-bar">
  <img id="cast-thumb" alt="poster" src="">
  <div style="flex:1 1 auto; min-width: 0;">
    <div id="cast-title">—</div>
    <input id="cast-seek" type="range" min="0" max="1000" value="0" />
    <div id="cast-time">00:00 / 00:00</div>
  </div>
  <div class="cast-controls">
    <button id="cast-play" title="Odtwarzaj">▶️</button>
    <button id="cast-pause" title="Pauza" style="display:none;">⏸️</button>
    <button id="cast-stop" title="Stop">⏹️</button>
  </div>
</div>



  <!-- Toast powiadomienie -->
<div id="toast" style="
  display: none;
  position: fixed;
  bottom: 6rem;
  left: 50%;
  transform: translateX(-50%);
  background: #323232;
  color: #fff;
  padding: 0.8rem 1.2rem;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
  z-index: 9999;
  font-size: 0.95rem;
">
  ✅ Torrent dodany
</div>

  <!-- Potwierdzenie usunięcia -->
<div id="confirm-modal" class="modal hidden">
  <div class="modal-content">
    <p id="confirm-message">Czy na pewno chcesz usunąć?</p>
    <div class="modal-buttons">
      <button id="confirm-yes">✅ Tak</button>
      <button id="confirm-no">❌ Nie</button>
    </div>
  </div>
</div>


<!-- FLOATING „LOSOWANIE” -->
<button id="rand-fab" title="Losuj film 🎲">🎲</button>

<!-- MODAL: wybór gatunków -->
<div id="rand-modal">
  <div class="rand-card">
    <div class="rand-title">Losowanie filmu – wybierz gatunki</div>

    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:.5rem;">
      <label class="switch-label small" style="margin:0;">
        <input type="checkbox" id="rand-select-all" class="switch-input">
        <span class="switch-slider"></span>
        <span style="font-weight:800; margin-left:.4rem;">Zaznacz wszystkie</span>
      </label>
      <small id="rand-status" style="opacity:.85;">Ładuję listę…</small>
    </div>

    <div id="rand-genres"></div>

    <div class="rand-actions">
      <button class="close" id="rand-cancel">Anuluj</button>
      <button class="rand-primary" id="rand-go">🎲 Losuj</button>
    </div>
  </div>
</div>

<!-- MODAL: wylosowany film -->
<div id="rand-result">
  <div class="rand-card rand-result-inner">
    <div class="rand-poster-wrap">
      <img id="rand-poster" class="rand-poster" src="" alt="poster">
    </div>
    <div id="rand-title" class="rand-title-film">—</div>
    <div id="rand-rolling-hint" style="display:none;">🎲 Losuję…</div> <!-- ⬅️ DODAJ TO -->
    <div class="rand-cta">
      <button class="cast" id="rand-cast">📺 CAST</button>
      <button class="close" id="rand-close">❌ Zamknij</button>
    </div>
  </div>
</div>

<!-- FAB do wysuwania livesearcha -->
<button id="live-toggle" class="lift-with-cast" title="Filtruj / wyszukaj">🔎</button>

<!-- Overlay + panel -->
<div id="live-overlay"></div>
<aside id="live-panel" aria-hidden="true">
  <div class="live-head">
    <b>Wyszukaj</b>
    <button id="live-close">✖</button>
  </div>
  <div class="live-body">
    <input id="live-query" type="text" placeholder="Wpisz tytuł… (na żywo)" autocomplete="off" />

    <div class="live-actions">
      <label class="switch-label small" style="margin:0;">
        <input type="checkbox" id="live-select-all" class="switch-input" checked>
        <span class="switch-slider"></span>
        <span style="font-weight:800; margin-left:.4rem;">Zaznacz wszystkie</span>
      </label>
      <small id="live-status" style="opacity:.85;">Ładuję gatunki…</small>
    </div>

    <div id="live-genres"></div>
  </div>
  <div class="live-foot">
    <span id="live-count">Widoczne: —</span>
    <button id="live-clear" class="reset-btn" type="button">Wyczyść</button>
  </div>
</aside>


<!-- Skrypty -->
<script>
  let activeTorrentView = "active";
document.addEventListener("DOMContentLoaded", () => {
  const themeToggle = document.getElementById('theme-toggle');
  if (themeToggle) {
    themeToggle.addEventListener('change', function () {
      document.body.setAttribute('data-theme', this.checked ? 'light' : 'dark');
    });
  }

  const searchResultsCache = {
    movies: null,
    premium: null,
    series: null
  };

  let pendingMagnetUrl = null;
  let activeSearchTab = "movies";


  const searchBtn = document.getElementById("search-button");
  if (searchBtn) {
    searchBtn.addEventListener("click", searchContent);
  }

  const modeToggle = document.getElementById("search-mode");
  const modeLabel = document.getElementById("search-mode-label");
  if (modeToggle && modeLabel) {
    modeToggle.addEventListener("change", () => {
      modeLabel.innerText = modeToggle.checked ? "📺 Seriale" : "🎬 Filmy";
    });
  }

window.showSection = function (name) {
  document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
  const section = document.getElementById(`section-${name}`);
  if (section) section.classList.add("active");

  // ⬇️ pokaż 🔎 tylko w "Dostępne"
  const liveBtn = document.getElementById('live-toggle');
  if (liveBtn) liveBtn.style.display = (name === 'available') ? 'grid' : 'none';
};


  window.browseMovies = browseMovies;
  window.openModal = openModal;
  window.closeModal = closeModal;
  window.toggle = toggle;
  window.removeTorrent = removeTorrent;
  window.confirmQuality = confirmQuality;
  window.downloadFromResult = downloadFromResult;
  window.searchContent = searchContent;
  document.querySelector("[data-available-tab='films']").click();
  loadTorrents();
  setInterval(loadTorrents, 2000);
  document.querySelectorAll("#torrent-tabs .search-tab").forEach(tab => {
    tab.addEventListener("click", () => {
      document.querySelectorAll("#torrent-tabs .search-tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      activeTorrentView = tab.dataset.torrentTab;
      loadTorrents();
    });
  });

  document.querySelectorAll(".search-tab[data-type]").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll(".search-tab[data-type]").forEach(t => t.classList.remove("active"));
    tab.classList.add("active");
    activeSearchTab = tab.getAttribute("data-type");

    const cached = searchResultsCache[activeSearchTab];
    if (cached) {
      renderResults(cached);
    } else {
      document.getElementById("search-results").innerHTML = "";
      document.getElementById("search-status").innerText = "";
    }
  });
});


  function formatSpeed(bps) {
    const kbps = bps / 1024;
    return kbps >= 1024 ? (kbps / 1024).toFixed(2) + " MB/s" : kbps.toFixed(2) + " KB/s";
  }

  function formatETA(seconds) {
    if (!seconds || seconds <= 0) return "–";
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}m ${s}s`;
  }

  function animateProgressBar(el, progress) {
    const percent = Math.max(progress, 0.1);
    el.style.width = percent.toFixed(1) + "%";
  }

async function loadTorrents() {
  const res = await fetch("/status");
  const data = await res.json();
  const container = document.getElementById("torrents");
  const summary = document.getElementById("summary");
  if (!container || !summary) return;

  container.innerHTML = "";
  const torrentsArray = Object.entries(data);
  const sortKey = document.getElementById("sort").value;

  torrentsArray.sort((a, b) => {
    const valA = a[1][sortKey], valB = b[1][sortKey];
    return typeof valA === "string" ? valA.localeCompare(valB) : valA - valB;
  });

  let totalSpeed = 0, activeCount = 0;

  for (const [id, t] of torrentsArray) {
    const isDone = t.progress >= 100;
    if ((activeTorrentView === "active" && isDone) || (activeTorrentView === "history" && !isDone)) continue;

    totalSpeed += t.download_payload_rate;
    if (t.state === "Downloading") activeCount++;

    const div = document.createElement("div");
    div.className = "torrent";
    div.innerHTML = `
      <div class="torrent-info" style="position: relative;">
        <div class="torrent-name"><b>${t.name}</b></div>
        <div class="torrent-details">📥 ${formatSpeed(t.download_payload_rate)} – ${t.state}</div>
        <div class="progress-bar"><div class="progress-bar-inner" style="width: 0%;"></div></div>
        <div class="torrent-buttons-row">
          <button onclick="toggle('${id}')">${t.state === "Paused" ? "▶️" : "⏸️"}</button>
          <button onclick="removeTorrent('${id}', false)">🗑️</button>
          <button onclick="removeTorrent('${id}', true)">🗑️ +📁 Usuń dane</button>
        </div>
      </div>
    `;
    container.appendChild(div);
    animateProgressBar(div.querySelector(".progress-bar-inner"), t.progress);
  }

  summary.innerText = `📊 Torrenty: ${torrentsArray.length}, 🚀 Aktywne: ${activeCount}, ⚡️ Prędkość: ${formatSpeed(totalSpeed)}`;
}


  async function toggle(id) {
    await fetch(`/toggle/${id}`, {method: "POST"});
    loadTorrents();
  }

  async function removeTorrent(id, withData = false) {
    await fetch(`/remove/${id}?data=${withData}`, {method: "POST"});
    loadTorrents();
  }

  function openModal(url) {
    pendingMagnetUrl = url;
    document.getElementById("quality-modal").style.display = "flex";
  }

  function closeModal() {
    document.getElementById("quality-modal").style.display = "none";
    pendingMagnetUrl = null;
  }

  async function confirmQuality() {
    const quality = document.getElementById("modal-quality").value;
    if (!pendingMagnetUrl) return;

    const url = pendingMagnetUrl;
    closeModal();
    pendingMagnetUrl = null;

    (async () => {
      try {
        const res = await fetch("/yts", {
          method: "POST",
          headers: {"Content-Type": "application/x-www-form-urlencoded"},
          body: `yts_url=${encodeURIComponent(url)}&quality=${encodeURIComponent(quality)}`
        });

        const data = await res.json();
        if (!data.magnet) {
          console.warn("❌ Magnet link nie znaleziony dla:", url);
          return;
        }

        await fetch("/", {
          method: "POST",
          headers: {"Content-Type": "application/x-www-form-urlencoded"},
          body: `magnet=${encodeURIComponent(data.magnet)}&source=movies`
        });

        showToast("✅ Torrent dodany");
      } catch (e) {
        console.error("❌ Błąd pobierania magnet linku:", e);
      }
    })();
  }

  async function downloadFromResult(input) {
    if (input.startsWith("magnet:")) {
      await fetch("/", {
        method: "POST",
        headers: {"Content-Type": "application/x-www-form-urlencoded"},
        body: `magnet=${encodeURIComponent(input)}&source=${activeSearchTab}`
      });
      showToast("✅ Torrent dodany");
    } else {
      openModal(input);
    }
  }

  async function searchContent() {
    let endpoint = "/search";
    if (activeSearchTab === "series") endpoint = "/search-series";
    else if (activeSearchTab === "anime") endpoint = "/search-anime";
    else if (activeSearchTab === "premium") endpoint = "/search-premium";

    const query = document.getElementById("search-query").value;
    const quality = document.getElementById("quality").value;
    const status = document.getElementById("search-status");
    const container = document.getElementById("search-results");

    status.innerText = "🔄 Trwa wyszukiwanie...";
    container.innerHTML = "";

    try {
      const body = `query=${encodeURIComponent(query)}&quality=${encodeURIComponent(quality)}`;

      const res = await fetch(endpoint, {
        method: "POST",
        headers: {"Content-Type": "application/x-www-form-urlencoded"},
        body
      });

      const data = await res.json();
      status.innerText = "";

      if (!data.results || !data.results.length) {
        status.innerText = "❌ Nic nie znaleziono.";
        return;
      }

      if (data.source === "tpb") {
        renderTPBResults(data.results);
      } else {
        renderResults(data.results);
      }

    } catch (e) {
      console.error("❌ Błąd:", e);
      status.innerText = "❌ Błąd podczas wyszukiwania.";
    }
  }

  async function browseMovies(page = 1) {
    const quality = document.getElementById("browse-quality").value || "0";
    const genre = document.getElementById("browse-genre").value || "0";
    const rating = document.getElementById("browse-rating").value || "0";
    const year = parseYear(document.getElementById("browse-year").value);
    const order = document.getElementById("browse-order").value || "latest";

    const params = new URLSearchParams({
      quality, genre, rating, year, order, page,
      language: "0", sort_by: "0"
    });

    const status = document.getElementById("browse-status");
    const container = document.getElementById("browse-results");
    const pagination = document.getElementById("browse-pagination");

    status.innerText = "🔄 Ładowanie...";
    container.innerHTML = "";
    pagination.innerHTML = "";

    try {
      const res = await fetch(`/browse?${params}`);
      const data = await res.json();
      status.innerText = "";

      if (!data.results.length) {
        status.innerText = "❌ Brak wyników.";
        return;
      }

      data.results.forEach(r => {
        const div = document.createElement("div");
        div.className = "browse-result";
        div.innerHTML = `
          <img src="${r.image}">
          <div class="result-content">
            <div style="display: flex; justify-content: space-between;">
              <b>${r.title}</b><span>⭐ ${r.rating || "–"}</span>
            </div>
            <div>${r.description || "Brak opisu"}</div>
            <button onclick="openModal('${r.url}')">🎯 Pobierz</button>
          </div>
        `;
        container.appendChild(div);
      });

      pagination.innerHTML = `
        <button onclick="browseMovies(${parseInt(page) - 1})" ${page <= 1 ? "disabled" : ""}>⬅️</button>
        <span>Strona ${page}</span>
        <button onclick="browseMovies(${parseInt(page) + 1})">➡️</button>
      `;

    } catch {
      status.innerText = "❌ Błąd podczas ładowania.";
    }
  }

  function parseYear(val) {
    if (!val || val === "") return "0";
    if (/^\d{4}$/.test(val)) return val;
    if (val === "2020-now") return "2020";
    if (val === "2010-now") return "2010";
    return "0";
  }

  function renderResults(results) {
    const container = document.getElementById("search-results");
    searchResultsCache[activeSearchTab] = results;
    container.innerHTML = "";

    results.forEach(r => {
      const div = document.createElement("div");
      div.className = "search-result";
      div.innerHTML = `
        <img src="${r.image || 'https://via.placeholder.com/100x150?text=Brak'}">
        <div class="result-content">
          <div style="display: flex; justify-content: space-between;">
            <b>${r.title}</b><span>⭐ ${r.rating || "–"}</span>
          </div>
          <div>${r.description || "Brak opisu"}</div>
          <button onclick="downloadFromResult('${r.url || r.magnet}')">🎯 Pobierz</button>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function renderTPBResults(results) {
  const container = document.getElementById("search-results");
  searchResultsCache[activeSearchTab] = results;
  container.innerHTML = "";

  results.forEach(r => {
    const imageUrl = (!r.image || r.image.includes("/static/logo.png"))
            ? "https://via.placeholder.com/100x150?text=Brak"
            : r.image;

    const div = document.createElement("div");
    div.className = "search-result";
    div.innerHTML = `
      <img src="${imageUrl}" />
      <div class="result-content">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h3 class="torrent-title">${r.title || 'Brak tytułu'}</h3>
          <span>⭐ ${r.rating || "–"}</span>
        </div>
        <div>${r.description || r.size || "Nieznany rozmiar"} – Seeds: ${r.seeds || "?"} – Leeches: ${r.leeches || "?"}</div>
        <button onclick="downloadFromResult('${r.magnet || ''}')">🎯 Pobierz</button>
      </div>
    `;
    container.appendChild(div);
  });
}


  function showToast(message = "✅ Torrent dodany") {
    const toast = document.getElementById("toast");
    if (!toast) return;

    toast.innerText = message;
    toast.style.display = "block";
    requestAnimationFrame(() => {
      toast.style.opacity = "1";
    });

    setTimeout(() => {
      toast.style.opacity = "0";
      setTimeout(() => {
        toast.style.display = "none";
      }, 300);
    }, 2000);
  }
})

  async function fetchTorrentStatus() {
    try {
      const res = await fetch("/status");
      const data = await res.json();
      if (data.error) {
        console.error("Błąd statusu:", data.error);
        return;
      }

      const list = document.getElementById("torrent-list");
      list.innerHTML = ""; // Wyczyść poprzednie dane

        Object.entries(data).forEach(([tid, t]) => {
            const div = document.createElement("div");
            div.className = "torrent-entry";
            div.innerHTML = `
                <h3>${t.name}</h3>
                <p>Postęp pobierania: ${t.progress.toFixed(1)}%</p>
                <p>Status: ${t.state}</p>
                <p>Szybkość: ${(t.download_payload_rate / 1024).toFixed(1)} KB/s</p>
                <p>ETA: ${t.eta} s</p>
                <p>📺 Postęp oglądania: ${t.viewing_progress}%</p>
            `;
            list.appendChild(div);
        });

    } catch (err) {
        console.error("❌ Błąd połączenia:", err);
    }
}


// ===== GENRES: cache + style map + render =====
(() => {
  // prościutki cache (id -> Promise<genres[]>), żeby nie spamować backendu
  const _promises = new Map();
  const _genresById = new Map();

  // mapowanie PL/EN nazw na „klucz” (do stylu)
  const norm = (g) => String(g||"").trim().toLowerCase()
    .replace(/[śłóąężźćń]/g, c => ({'ś':'s','ł':'l','ó':'o','ą':'a','ę':'e','ż':'z','ź':'z','ć':'c','ń':'n'}[c]||c))
    .replace(/\s+/g,'-');

  // motywy kolorów (tło = gradient)
  const STYLE = {
    'horror':'linear-gradient(135deg,#0b0004,#ff2a2a)',
    'komedia':'linear-gradient(135deg,#ffb300,#ff5a00)',
    'comedy':'linear-gradient(135deg,#ffb300,#ff5a00)',
    'akcja':'linear-gradient(135deg,#c600ff,#00f0ff)',
    'action':'linear-gradient(135deg,#c600ff,#00f0ff)',
    'dramat':'linear-gradient(135deg,#2b2c6f,#6a5acd)',
    'drama':'linear-gradient(135deg,#2b2c6f,#6a5acd)',
    'thriller':'linear-gradient(135deg,#1b1b1b,#7cff00)',
    'sci-fi':'linear-gradient(135deg,#00e0ff,#00b894)',
    'science-fiction':'linear-gradient(135deg,#00e0ff,#00b894)',
    'fantasy':'linear-gradient(135deg,#6728ff,#00e0ff)',
    'romans':'linear-gradient(135deg,#ff3d77,#ff7eb3)',
    'romance':'linear-gradient(135deg,#ff3d77,#ff7eb3)',
    'animacja':'linear-gradient(135deg,#ff6bd6,#ff9a3d)',
    'animation':'linear-gradient(135deg,#ff6bd6,#ff9a3d)',
    'kryminal':'linear-gradient(135deg,#0d0d15,#f5d000)',
    'crime':'linear-gradient(135deg,#0d0d15,#f5d000)',
    'dokument':'linear-gradient(135deg,#243949,#517fa4)',
    'documentary':'linear-gradient(135deg,#243949,#517fa4)',
    'familijny':'linear-gradient(135deg,#56ccf2,#2f80ed)',
    'family':'linear-gradient(135deg,#56ccf2,#2f80ed)',
    'wojenny':'linear-gradient(135deg,#3a6073,#16222a)',
    'war':'linear-gradient(135deg,#3a6073,#16222a)',
    'western':'linear-gradient(135deg,#a770ef,#fdb99b)',
    'history':'linear-gradient(135deg,#8360c3,#2ebf91)',
    'muzyka':'linear-gradient(135deg,#ff512f,#dd2476)',
    'music':'linear-gradient(135deg,#ff512f,#dd2476)',
    'mystery':'linear-gradient(135deg,#0f2027,#203a43)',
    'przygodowy':'linear-gradient(135deg,#00b09b,#96c93d)',
    'adventure':'linear-gradient(135deg,#00b09b,#96c93d)'
  };

  async function fetchGenresForId(id){
    id = String(id);
    if (_genresById.has(id)) return _genresById.get(id);
    if (_promises.has(id)) return _promises.get(id);

    const p = (async () => {
      try{
        const r = await fetch(`/genres/for-id/${encodeURIComponent(id)}`);
        const j = await r.json();
        const arr = Array.isArray(j.genres) ? j.genres : [];
        _genresById.set(id, arr);
        return arr;
      }catch(_){
        _genresById.set(id, []);
        return [];
      }finally{
        _promises.delete(id);
      }
    })();

    _promises.set(id, p);
    return p;
  }

  function badgeEl(name){
    const key = norm(name);
    const bg = STYLE[key];
    const span = document.createElement('span');
    span.className = 'genre-badge' + (bg ? '' : ' is-generic');
    span.textContent = name;
    span.style.background = bg || 'linear-gradient(135deg,#6a6aff,#39d1ff)';
    return span;
  }

  // publiczny renderer — wołaj z loadPlexFilms / loadPlexSeries
  window.renderGenresBadges = async function(containerEl, filmId){
    if (!containerEl || !filmId) return;
    containerEl.innerHTML = '';
    const genres = await fetchGenresForId(filmId);
    if (!genres || !genres.length) return;
    const frag = document.createDocumentFragment();
    genres.forEach(g => frag.appendChild(badgeEl(String(g))));
    containerEl.appendChild(frag);
  };

  // >>> to było przyczyną błędu — musi być wewnątrz IIFE
  window.getGenresForId = fetchGenresForId;
})();


  document.getElementById("global-speed-limit").addEventListener("change", function () {
  const limit = this.value;
  fetch("/set-global-limit", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ limit })
  })
    .then(res => res.json())
    .then(data => {
      if (data.status === "ok") {
        alert(`✅ Ograniczono do ${limit > 0 ? limit + " MB/s" : "brak limitu"}`);
      } else {
        alert("❌ Błąd ustawiania limitu");
      }
    });
});

  document.querySelectorAll("#available-tabs .search-tab").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll("#available-tabs .search-tab").forEach(t => t.classList.remove("active"));
    tab.classList.add("active");

    const type = tab.dataset.availableTab;
    document.querySelectorAll(".available-tab-content").forEach(s => s.classList.remove("active"));
    document.getElementById(`available-${type}`).classList.add("active");

    if (type === "films") loadPlexFilms();
    if (type === "series") loadPlexSeries();
  });
});


// === 1) Jedna, wspólna funkcja countdown (usuń duplikaty) ===
function getCountdown(targetTime) {
  const now = Date.now();
  const diff = targetTime - now;
  if (!Number.isFinite(diff)) return "–";
  if (diff <= 0) return "✅ Do usunięcia";

  const d = Math.floor(diff / 86400000);
  const h = Math.floor((diff % 86400000) / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  const s = Math.floor((diff % 60000) / 1000);

  if (d > 0) return `⏳ ${d}d ${h}h`;
  if (h > 0) return `⏳ ${h}h ${m}m`;
  if (m > 0) return `⏳ ${m}m ${s}s`;
  return `⏳ ${s}s`;
}

// globalne, lekkie odświeżanie kapsli z timerem
function ensureCountdownLoop() {
  if (window._countdownLoop) return;
  window._countdownLoop = setInterval(() => {
    document.querySelectorAll('[data-target]').forEach(el => {
      const ts = Number(el.dataset.target);
      if (Number.isFinite(ts)) el.textContent = getCountdown(ts);
    });
  }, 1000);
}

// === 2) Pomocnicze: wylicz deadline tylko dla 100% obejrzanych ===
function deadlineForFilm(film) {
  const progress = Number(film.progress) || 0;
  if (progress < 100) return null; // <— kluczowe
  const del = Number(film.deleteAt);
  if (Number.isFinite(del)) return del;

  const watchedAt = Number(film.watchedAt);
  if (Number.isFinite(watchedAt) && watchedAt > 0) {
    return watchedAt + 7 * 86400000;
  }
  return null;
}

function deadlineForSeries(series) {
  const progress = Number(series.progress) || 0;
  if (progress < 100) return null; // <— kluczowe
  const del = Number(series.deleteAt);
  return Number.isFinite(del) ? del : null; // dla seriali polegamy na deleteAt z backendu
}

// === FILMY — desktop: badges w prawym górnym rogu; mobile: pod postępem ===
async function loadPlexFilms() {
  const loader = document.getElementById("loading-message");
  const container = document.getElementById("available-films");
  if (!loader || !container) return;

  loader.style.display = "block";
  container.innerHTML = "";

  try {
    const res = await fetch("/plex/films");
    let data = await res.json();
    loader.style.display = "none";

    // ⛑️ Asekuracja: odfiltruj rzeczy, które wyglądają na seriale
    data = (Array.isArray(data) ? data : []).filter(f => {
      const t = String(f.type || '').toLowerCase();
      const looksLikeSeries = Array.isArray(f.episodes) && f.episodes.length > 0;
      const isFilmType = (t === '' || t === 'film' || t === 'movie');
      return isFilmType && !looksLikeSeries;
    });

    data.forEach(film => {
      const deadline = deadlineForFilm(film); // null albo timestamp

      const div = document.createElement("div");
      div.className = "browse-result";
      div.innerHTML = `
        <img src="${film.thumb || 'https://via.placeholder.com/100x150'}" />
        <div class="result-content">
          <b>${film.title}</b>

          <div class="progress-bar">
            <div class="progress-bar-inner" style="width:${Number(film.progress)||0}%;"></div>
          </div>
          <small>${Number(film.progress)||0}% obejrzane</small>

          <!-- GENRES: w DOM od razu pod progress barem (mobile), na desktopie przeskoczą w róg -->
          <div class="genre-badges" id="genres-${film.id}"></div>

          <div style="margin-top:.6rem; display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; justify-content:space-between;">
            <div style="font-size:.85rem; display:flex; align-items:center; gap:.5rem;">
              <span data-timer="${film.id}" ${deadline ? `data-target="${deadline}"` : ""}>
                ${deadline ? getCountdown(deadline) : "–"}
              </span>
              ${deadline ? `<button class="reset-btn" onclick="resetDeleteTimer('${film.id}')">🔁 Resetuj</button>` : ""}
            </div>

            <div style="display:flex; gap:.5rem;">
              <button onclick='openCastModalForItem(${JSON.stringify({ id:String(film.id), title:film.title })})'>📺 CAST</button>
              <button onclick="confirmDelete('${film.id}', '${film.title}', 'film')">🗑️ Usuń teraz</button>
            </div>
          </div>
        </div>
      `;
      container.appendChild(div);

      // dla livesearcha
      div.dataset.title = (film.title || '').toLowerCase();

      // Badges gatunków
      const badgeBox = div.querySelector(`#genres-${film.id}`);
      if (badgeBox && typeof renderGenresBadges === "function") {
        renderGenresBadges(badgeBox, film.id);
      }

      // data-genres (dla filtra bocznego)
      if (typeof attachGenresData === "function") {
        attachGenresData(div, film.id);
      }
    });

    // globalny loop odliczania
    ensureCountdownLoop();
  } catch (err) {
    loader.innerHTML = "❌ Błąd ładowania filmów.";
    console.error(err);
  }
}


// === 4) SERIALE — analogicznie z warunkiem 100% ===
// === SERIALE — badge gatunków tylko dla całego serialu ===
async function loadPlexSeries(){
  const loader = document.getElementById("loading-message");
  const container = document.getElementById("available-series");
  if (!container) return;

  loader.style.display = "block";
  container.innerHTML = "";

  try{
    const res = await fetch("/plex/series");
    const data = await res.json();
    loader.style.display = "none";

    data.forEach(series => {
      const deadline = deadlineForSeries(series);
      const seasons  = computeSeasonStats(series.episodes || []);
      const next     = nextEpisode(series.episodes || []);

      const chips = Object.entries(seasons)
        .sort((a,b) => Number(a[0]) - Number(b[0]))
        .map(([sn, st]) => `
          <div class="chip ${st.done===st.total && st.total>0 ? 'done':''}">
            <span class="num">Sezon ${sn}</span>
            <span class="meta">${st.done}/${st.total}</span>
          </div>
        `).join("");

      const card = document.createElement("details");
      card.className = "series-card";
      card.innerHTML = `
        <summary class="series-top">
          <img class="series-poster" src="${esc(series.thumb||'')}" alt="${esc(series.title)}">
          <div class="series-main">
            <h3 class="series-title">${esc(series.title)}</h3>

            <div class="series-progress">
              <div class="bar"><div class="fill" style="width:${Number(series.progress)||0}%"></div></div>
              <small>${Number(series.progress)||0}% obejrzane</small>
            </div>

            <!-- GENRES (SERIES): placeholder na badge
                 - Desktop: będzie w prawym górnym rogu dzięki position:absolute (rodzic .series-card)
                 - Mobile: pojawi się tutaj pod paskiem postępu, małe i obok siebie -->
            <div class="genre-badges" id="genres-${series.id}"></div>

          </div>
          <div class="series-caret">›</div>
        </summary>

        <div class="series-timer">
          ${next ? `
            <button onclick='openCastModalForItem(
              ${JSON.stringify({ id: String(next.id), title: episodeLabel(series,next), thumb: series.thumb || "" })}
            )'>▶️ Odtwarzaj dalej</button>
          ` : ``}

          ${deadline ? `
            <span data-timer-id="${series.id}" data-target="${deadline}">${getCountdown(deadline)}</span>
            <button class="reset-btn" onclick="event.stopPropagation(); resetDeleteTimer('${series.id}')">🔁 Resetuj</button>
          ` : ``}

          <button class="btn-danger" onclick="event.stopPropagation(); confirmDelete('${series.id}','${esc(series.title)}','series')">🗑️ Usuń</button>
        </div>

        ${chips ? `<div class="season-chips">${chips}</div>` : ``}

        <div class="series-seasons">
          ${Object.entries(seasons).map(([sn, st]) => `
            <details>
              <summary>📁 Sezon ${sn} — ${st.done}/${st.total}</summary>
              <ul>
                ${st.list.sort((a,b)=>a.episode - b.episode).map(ep => `
                  <li>
                    ${ep.episode}. ${esc(ep.title)} — <b>${ep.progress}%</b>
                    <button style="font-size:.75rem; margin-left:10px;"
                      onclick="event.stopPropagation(); confirmDelete('${ep.id}','${esc(ep.title)}','episode')">🗑️</button>
                    <button style="font-size:.75rem; margin-left:10px;"
                      onclick='event.stopPropagation(); openCastModalForItem(
                        ${JSON.stringify({ id: String(ep.id), title: episodeLabel(series,ep), thumb: series.thumb || "" })}
                      )'>📺</button>
                  </li>
                `).join("")}
              </ul>
            </details>
          `).join("")}
        </div>
      `;

      container.appendChild(card);

      // === GENRES tylko dla całego serialu (po wstawieniu karty):
      const badgeBox = card.querySelector(`#genres-${series.id}`);
      if (badgeBox && typeof renderGenresBadges === "function") {
        renderGenresBadges(badgeBox, series.id);
      }
      if (typeof attachGenresData === "function") attachGenresData(card, series.id);
    });

    ensureCountdownLoop();
  } catch(e){
    loader.innerHTML = "❌ Błąd ładowania seriali.";
    console.error(e);
  }
}


// === 5) Reset timera — natychmiast aktualizuje wszystkie kapsle tej pozycji ===
async function resetDeleteTimer(id) {
  if (!confirm("Zresetować czas usunięcia (7 dni od teraz)?")) return;

  try {
    const res = await fetch("/plex/reset-delete-timer", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id })
    });
    const data = await res.json();

    if (res.ok && data.success && Number.isFinite(data.newDeleteAt)) {
      document.querySelectorAll(`[data-timer="${id}"], [data-timer-id="${id}"]`).forEach(el => {
        el.dataset.target = String(data.newDeleteAt);
        el.textContent = getCountdown(data.newDeleteAt);
      });
      ensureCountdownLoop();
    } else {
      alert("❌ Błąd resetowania: " + (data.error || "nieznany błąd"));
    }
  } catch (e) {
    console.error("❌ Błąd połączenia:", e);
    alert("❌ Błąd połączenia z serwerem");
  }
}



document.addEventListener("DOMContentLoaded", () => {
  const select = document.getElementById("global-speed-limit");
  const feedback = document.getElementById("global-speed-feedback");

  async function applyLimit(mbs) {
    try {
      select.disabled = true;
      feedback.textContent = mbs > 0 ? `Ustawiam ${mbs} MB/s…` : "Wyłączam limit (Unlimited)…";

      const res = await fetch("/set-global-limit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ limit: mbs }) // MB/s
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Błąd ustawiania limitu");

      const shown = (Number(data.limit_mbs) > 0) ? `${data.limit_mbs} MB/s` : "Unlimited";
      feedback.textContent = `✅ Globalny limit pobierania: ${shown}`;
      localStorage.setItem("global-speed-limit", String(mbs));
    } catch (err) {
      feedback.textContent = `❌ ${err.message || err}`;
    } finally {
      select.disabled = false;
    }
  }

  // Przywróć ostatni wybór z localStorage (i od razu go ustaw)
  const saved = localStorage.getItem("global-speed-limit");
  if (saved !== null) {
    select.value = saved;
    applyLimit(Number(saved));
  } else {
    feedback.textContent = "Aktualnie: Unlimited";
  }

  // Zmiana z UI -> API
  select.addEventListener("change", (e) => {
    const mbs = parseFloat(e.target.value);
    applyLimit(isNaN(mbs) ? 0 : mbs);
  });
});

if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
        // prosty hot-update: jeśli pojawi się nowy SW, odśwież po instalacji
        reg.addEventListener('updatefound', () => {
          const nw = reg.installing;
          if (!nw) return;
          nw.addEventListener('statechange', () => {
            if (nw.state === 'installed' && navigator.serviceWorker.controller) {
              console.log('🔄 Aktualizacja Piotrflix dostępna – odświeżam…');
              // możesz zamiast tego pokazać własny toast/btn
              location.reload();
            }
          });
        });
      } catch (e) { console.warn('SW error', e); }
    });

    // ...
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    const installBtn = document.getElementById('install-btn');
    if (installBtn) installBtn.classList.remove('hidden');
  });

  // zamiast document.getElementById('install-btn').onclick = ...
  (function(){
    const installBtn = document.getElementById('install-btn');
    if (!installBtn) return;
    installBtn.onclick = async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
    };
  })();
  }

/* ====== MOTYW – zapamiętaj w localStorage ====== */
document.addEventListener("DOMContentLoaded", () => {
  const toggle = document.getElementById('theme-toggle');
  const savedTheme = localStorage.getItem('piotrflix-theme') || 'dark';
  document.body.setAttribute('data-theme', savedTheme);
  if (toggle) toggle.checked = (savedTheme === 'light');
  if (toggle) toggle.addEventListener('change', () => {
    const theme = toggle.checked ? 'light' : 'dark';
    document.body.setAttribute('data-theme', theme);
    localStorage.setItem('piotrflix-theme', theme);
  });
});

/* ====== „Dostępne” — poprawna inicjalizacja zakładki po starcie ====== */

/* ===== Helper do bezpiecznego cytowania w atrybutach JS ===== */
function jsq(s){ return JSON.stringify(String(s ?? "")); }



/* ====== Potwierdzenie + kasowanie (film/serial/odcinek) ====== */
function confirmDelete(id, title, type){
  const modal = document.getElementById('confirm-modal');
  const msg   = document.getElementById('confirm-message');
  const yes   = document.getElementById('confirm-yes');
  const no    = document.getElementById('confirm-no');

  if(!modal || !yes || !no || !msg){
    if (confirm(`Usunąć "${title}"?`)) doDelete(id, type);
    return;
  }

  msg.textContent = `Czy na pewno chcesz usunąć: ${title}?`;
  modal.classList.remove('hidden');
  modal.classList.add('show');

  const close = () => { modal.classList.remove('show'); modal.classList.add('hidden'); };

  yes.onclick = () => { close(); doDelete(id, type); };
  no.onclick  = () => { close(); };

  // klik w tło
  modal.onclick = (e) => { if (e.target === modal) close(); };
  // ESC
  const esc = (e) => { if (e.key === 'Escape') close(); };
  document.addEventListener('keydown', esc, { once:true });
}

async function doDelete(id, type){
  try{
    const force = (type !== 'film'); // serial/episode -> rekurencyjnie
    const res = await fetch('/plex/delete', {
      method: 'DELETE',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ id, force })
    });
    const data = await res.json();

    if(!res.ok || !data.success){
      alert('❌ Błąd usuwania: ' + (data.error || 'nieznany'));
      return;
    }

    if (typeof showToast === "function") showToast('🗑️ Usunięto');

    // odśwież aktywną zakładkę "Dostępne"
    const activeAvail = document.querySelector('#available-tabs .search-tab.active');
    if (activeAvail?.dataset.availableTab === 'series') {
      if (typeof loadPlexSeries === "function") loadPlexSeries();
    } else if (activeAvail?.dataset.availableTab === 'films') {
      if (typeof loadPlexFilms === "function") loadPlexFilms();
    }
  }catch(e){
    console.error(e);
    alert('❌ Błąd połączenia przy usuwaniu');
  }
}

/* ====== Utils ====== */
function computeSeasonStats(episodes){
  const map = {};
  for (const ep of (episodes||[])) {
    const s = ep.season;
    if (!map[s]) map[s] = { total:0, done:0, list:[] };
    map[s].total++;
    map[s].list.push(ep);
    if ((Number(ep.progress)||0) >= 100) map[s].done++;
  }
  return map;
}
function esc(s){
  return String(s||"").replace(/[&<>"']/g, m => (
    {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]
  ));
}

/* ======================= POSTERS (cache z backendu) ======================= */
function esc(s){ return String(s==null?'':s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

const PosterCache = (() => {
  const map = new Map(); // ratingKey (id) -> URL (nasza ścieżka lub gotowy thumb z backendu)
  const norm = (u) => {
    if (!u) return null;
    const s = String(u).trim();
    if (!s) return null;
    if (s.startsWith('/')) return s;
    if (/^https?:\/\//i.test(s)) return s;
    return '/' + s.replace(/^\/+/, '');
  };
  const remember = (id, url) => { if (id!=null && url) map.set(String(id), norm(url)); };
  return {
    remember,
    get: (id) => map.get(String(id)) || null,
    preload: async () => {
      try{
        const [rf, rs] = await Promise.all([fetch('/plex/films'), fetch('/plex/series')]);
        const films  = await rf.json();
        const series = await rs.json();
        if (Array.isArray(films)) films.forEach(f => remember(f.id, f.thumb));
        if (Array.isArray(series)) {
          series.forEach(s => {
            remember(s.id, s.thumb);
            (s.episodes||[]).forEach(ep => remember(ep.id, s.thumb)); // odcinek -> plakat serialu
          });
        }
      }catch(_){}
    }
  };
})();
PosterCache.preload();

async function attachCastPoster(imgEl, meta){
  if (!imgEl) return;
  const id    = String((meta && (meta.itemId || meta.id)) || "");
  let thumb   = (meta && meta.thumb) ? String(meta.thumb) : "";

  // preferuj nasz cache; jeśli brak, użyj meta.thumb
  const cached = id ? PosterCache.get(id) : null;
  const src = cached || thumb || "https://via.placeholder.com/92x92?text=%20";

  imgEl.onerror = () => { imgEl.onerror=null; imgEl.src="https://via.placeholder.com/92x92?text=%20"; };
  imgEl.src = src;
}

/* ======================= CAST – stan ======================= */
window._cast = {
  active:false, clientId:null, itemId:null,
  title:"", thumb:"", durationMs:0, viewOffsetMs:0, state:"unknown",
  pollTimer:null, userScrubbing:false,
  lastServerNow:0, lastOffset:0
};

function msToClock(ms){
  ms = Math.max(0, Number(ms)||0);
  const s = Math.floor(ms/1000);
  const hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60), ss = s%60;
  return (hh>0? `${hh}:${String(mm).padStart(2,'0')}`: `${mm}`) + `:${String(ss).padStart(2,'0')}`;
}

function showCastBar(meta){
  const bar = document.getElementById('cast-bar');
  const t   = document.getElementById('cast-title');
  const img = document.getElementById('cast-thumb');

  if (meta){
    window._cast.title  = meta.title  || window._cast.title || 'Odtwarzanie';
    window._cast.itemId = meta.itemId || window._cast.itemId;
    window._cast.thumb  = meta.thumb  || window._cast.thumb || '';
  }
  if (t) t.textContent = window._cast.title || '—';

  if (img) attachCastPoster(img, { itemId: window._cast.itemId, thumb: window._cast.thumb });

  if (bar) bar.style.display = 'flex';
  window._cast.active = true;
  document.body.classList.add('cast-active');
}

function hideCastBar(){
  const bar = document.getElementById('cast-bar');
  if (bar) bar.style.display = 'none';
  window._cast.active = false;
  if (window._cast.pollTimer){ clearInterval(window._cast.pollTimer); window._cast.pollTimer=null; }
  document.body.classList.remove('cast-active');
}

/* ======= HARD STOP: natychmiastowe zamknięcie playera ======= */
async function hardStopCast(){
  // optymistycznie schowaj UI i wyczyść stan
  hideCastBar();
  const cid = window._cast.clientId;
  window._cast = {
    active:false, clientId:null, itemId:null,
    title:"", thumb:"", durationMs:0, viewOffsetMs:0, state:"stopped",
    pollTimer:null, userScrubbing:false, lastServerNow:0, lastOffset:0
  };
  // spróbuj zatrzymać w tle (fire-and-forget)
  if (cid){
    try {
      await fetch('/plex/cast/cmd', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ client_id: cid, cmd:'stop' })
      });
    } catch(_) {}
  }
}

/* ======================= CAST – modal ======================= */
let _castSelectedClient = null;

async function openCastModalForItem(item){
  _castSelectedClient = null;
  const modal = document.getElementById('cast-modal');
  const list  = document.getElementById('cast-devices');
  const btn   = document.getElementById('cast-confirm');
  if (btn) btn.disabled = true;

  // ustaw meta, ALE nie pokazuj jeszcze mini-playera!
  window._cast.itemId = String(item.id);
  window._cast.title  = item.title;
  window._cast.thumb  = item.thumb || "";
  window._cast.state  = 'idle';

  if (modal) {
    modal.classList.add('show');
    modal.style.removeProperty('display');
  }
  if (list) list.innerHTML = '🔄 Szukam urządzeń…';

  try{
    const res = await fetch('/plex/players');
    const data = await res.json();
    const devices = (data.devices||[]);
    if (!devices.length){
      if (list) list.innerHTML='❌ Brak klientów Plex.';
      return;
    }
    if (list) list.innerHTML = '';
    devices.forEach(d=>{
      const row = document.createElement('div');
      row.className = 'cast-device';
      row.innerHTML = `<div>
          <div style="font-weight:800">${esc(d.name||'Plex Client')}</div>
          <div style="opacity:.8;font-size:.9rem">${esc(d.platform||'')}</div>
        </div><div>✔️</div>`;
      row.onclick = ()=>{
        _castSelectedClient = d.id;
        list.querySelectorAll('.cast-device').forEach(x=>x.classList.remove('selected'));
        row.classList.add('selected');
        if (btn) btn.disabled = false;
      };
      list.appendChild(row);
    });
    if (btn) btn.onclick = startCastOnSelected;
  }catch(e){
    if (list) list.innerHTML='❌ Błąd pobierania listy.';
  }
}

function closeCastModal() {
  const m = document.getElementById('cast-modal');
  if (!m) return;
  // 1) zdejmij klasę, 2) schowaj display
  m.classList.remove('show');
  m.style.display = 'none';

  // jeśli nie ma aktywnego klienta (cast nie wystartował) — schowaj pasek
  if (!window._cast.clientId) hideCastBar();
  _castSelectedClient = null;
}

(function wireCastModalDismiss() {
  const m = document.getElementById('cast-modal');
  if (!m || m._wiredDismiss) return;
  m._wiredDismiss = true;

  // klik w overlay
  m.addEventListener('click', (e) => {
    if (e.target === m) closeCastModal();
  });
  // klawisz ESC
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && m.classList.contains('show')) closeCastModal();
  });
})();

/* ======= start cast po wyborze klienta ======= */
async function startCastOnSelected() {
  const btn = document.getElementById('cast-confirm');
  if (!window._cast.itemId || !_castSelectedClient) return;

  // jeżeli mamy zapisany offset z poprzedniej sesji — dołącz do startu
  const resumeState = loadSavedCastState(window._cast.itemId);
  const resume_ms   = resumeState?.view_offset_ms ?? null;

  try {
    if (btn) { btn.disabled = true; btn.textContent = '⏳ Uruchamiam…'; }

    const res = await fetch('/plex/cast/start', {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({
        client_id: _castSelectedClient,
        item_id  : window._cast.itemId,
        ...(Number.isFinite(resume_ms) && resume_ms > 0 ? { resume_ms } : {})
      })
    });

    const data = await res.json();
    if (!res.ok || data.error) throw new Error(data.error || 'Start failed');

    // zarejestruj sesję
    window._cast.clientId = _castSelectedClient;
    window._cast.state    = 'buffering';

    // pokaż pasek dopiero PO udanym starcie:
    showCastBar({ itemId: window._cast.itemId, title: window._cast.title, thumb: window._cast.thumb });
    closeCastModal();     // <- teraz modal na pewno znika
    startCastPolling();   // i zaczynamy odświeżanie stanu
  } catch (err) {
    alert('❌ Nie udało się uruchomić odtwarzania: ' + (err.message || err));
    if (btn) { btn.disabled = false; btn.textContent = '▶️ Odtwarzaj tutaj'; }
  }
}

/* ======================= CAST – UI + polling ======================= */
function renderCastUI(){
  const playBtn=document.getElementById('cast-play');
  const pauseBtn=document.getElementById('cast-pause');
  const seek=document.getElementById('cast-seek');
  const time=document.getElementById('cast-time');

  const st=(window._cast.state||'').toLowerCase();
  const isPlaying=(st==='playing'||st==='buffering');

  if(playBtn)  playBtn.style.display=isPlaying?'none':'';   // pokaż „Play” tylko gdy pauza
  if(pauseBtn) pauseBtn.style.display=isPlaying?'':'none';  // pokaż „Pause” tylko gdy gra

  let offset = Math.max(0, Number(window._cast.viewOffsetMs)||0);
  const dur  = Math.max(0, Number(window._cast.durationMs)||0);

  if (isPlaying && !window._cast.userScrubbing && window._cast.lastServerNow){
    const delta = Date.now() - window._cast.lastServerNow;
    if (Number.isFinite(delta) && delta >= 0) {
      offset = Math.min(dur || Infinity, (window._cast.lastOffset||0) + delta);
    }
  }

  if (seek && !window._cast.userScrubbing){
    const max = dur>0 ? dur : 1000;
    seek.max = max;
    seek.value = Math.max(0, Math.min(max, offset));
  }
  if (time) time.textContent = `${msToClock(offset)} / ${msToClock(dur)}`;
}

async function pollCastOnce(){
  if (!window._cast.clientId) return;
  try{
    const res=await fetch(`/plex/cast/status?client_id=${encodeURIComponent(window._cast.clientId)}`);
    const data=await res.json();
    if(!res.ok||data.error) return;

    const s=(data.sessions||[])[0];
    if(!s){
      // brak sesji – nie chowamy od razu; UI można zamknąć przyciskiem Stop (hardStopCast)
      window._cast.state = 'buffering';
      renderCastUI();
      return;
    }

    window._cast.itemId       = s.item_id || window._cast.itemId;
    window._cast.title        = s.title   || window._cast.title;
    window._cast.durationMs   = Number(s.duration_ms)||window._cast.durationMs||0;
    window._cast.viewOffsetMs = Number(s.view_offset_ms)||0;
    window._cast.lastOffset   = window._cast.viewOffsetMs;
    window._cast.lastServerNow= Number(s.server_now_ms)||Date.now();
    window._cast.state        = s.state || window._cast.state || 'unknown';

    const cached = PosterCache.get(window._cast.itemId);
    window._cast.thumb = cached || s.thumb || window._cast.thumb || '';

    const t = document.getElementById('cast-title');
    if (t && (t.textContent==='—' || !window._cast.active)){
      showCastBar({title:window._cast.title, itemId:window._cast.itemId, thumb:window._cast.thumb});
    }
    const img = document.getElementById('cast-thumb');
    if (img) attachCastPoster(img, { itemId: window._cast.itemId, thumb: window._cast.thumb });

    renderCastUI();
  }catch(_){}
}

function startCastPolling(){
  if(window._cast.pollTimer) clearInterval(window._cast.pollTimer);
  pollCastOnce();
  window._cast.pollTimer=setInterval(pollCastOnce, 1500);
}

/* ======================= CAST – komendy ======================= */
async function castCmd(cmd,argMs){
  if(!window._cast.clientId && cmd!=='stop'){ return; }
  if(cmd==='stop'){ return hardStopCast(); } // <— klucz: natychmiast chowamy

  const body={client_id:window._cast.clientId,cmd};
  if(cmd==='seek') body.seek_ms=Math.max(0,Number(argMs)||0);

  if(cmd==='pause') window._cast.state='paused';
  if(cmd==='play')  window._cast.state='playing';

  renderCastUI();

  try{
    const res=await fetch('/plex/cast/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const data=await res.json();
    if(!res.ok||data.error) console.warn('CAST cmd fail',cmd,data.error||res.status);
    else setTimeout(pollCastOnce,500);
  }catch(e){ console.warn('CAST cmd net err',cmd,e.message); }
}

/* ======================= Kontrolki mini-playera ======================= */
(function bindCastControls(){
  const play=document.getElementById('cast-play');
  const pause=document.getElementById('cast-pause');
  const stop=document.getElementById('cast-stop');
  const seek=document.getElementById('cast-seek');

  if(play)  play.onclick=()=>castCmd('play');
  if(pause) pause.onclick=()=>castCmd('pause');
  if(stop)  stop.onclick=hardStopCast; // <— natychmiastowe zamknięcie

  if(seek){
    seek.addEventListener('input',()=>{window._cast.userScrubbing=true;});
    seek.addEventListener('change',()=>{ castCmd('seek', Number(seek.value)||0); window._cast.userScrubbing=false; });
  }
})();

/* ======================= Auto-attach istniejącej sesji ======================= */
document.addEventListener('DOMContentLoaded', async ()=>{
  try{
    const res = await fetch('/plex/cast/status');
    const data = await res.json();
    const s = (data.sessions||[])[0];
    if (!s) return;

    window._cast.clientId     = s.client_id;
    window._cast.itemId       = s.item_id;
    window._cast.title        = s.title || '';
    window._cast.durationMs   = Number(s.duration_ms)||0;
    window._cast.viewOffsetMs = Number(s.view_offset_ms)||0;
    window._cast.lastOffset   = window._cast.viewOffsetMs;
    window._cast.lastServerNow= Number(s.server_now_ms)||Date.now();
    window._cast.state        = s.state||'unknown';

    const cached = PosterCache.get(window._cast.itemId);
    window._cast.thumb = cached || s.thumb || '';

    showCastBar({ title: window._cast.title, itemId: window._cast.itemId, thumb: window._cast.thumb });
    startCastPolling();
  }catch(_){}
});

function episodeLabel(series, ep){
  const sNum = Number(ep.season ?? ep.season_number ?? 0);
  const eNum = Number(ep.episode ?? ep.episode_number ?? 0);
  const s = sNum > 0 ? String(sNum).padStart(2,'0') : '00';
  const e = eNum > 0 ? String(eNum).padStart(2,'0') : '00';
  const stitle = series?.title || '';
  const etitle = ep?.title || '';
  return `${stitle} S${s}E${e}${etitle ? ' — ' + etitle : ''}`;
}

function nextEpisode(episodes){
  if (!Array.isArray(episodes)) return null;
  // posortuj po sezonie/odcinku i weź pierwszy <100%
  const list = episodes.slice().sort((a,b)=>{
    const sa = Number(a.season||0), sb = Number(b.season||0);
    if (sa !== sb) return sa - sb;
    return Number(a.episode||0) - Number(b.episode||0);
  });
  return list.find(ep => (Number(ep.progress)||0) < 100) || null;
}
/* ====== Offset/Progress — zapisz na wyjściu, wznów na starcie ====== */

/* Bieżący offset sesji, licząc płynnie od ostatniej odpowiedzi serwera */
function currentCastOffsetMs() {
  const dur = Math.max(0, Number(window._cast.durationMs) || 0);
  let off   = Math.max(0, Number(window._cast.viewOffsetMs) || 0);

  // jeżeli „gra”, dolicz czas od ostatniego ticka serwera
  const st = String(window._cast.state || '').toLowerCase();
  const playing = st === 'playing' || st === 'buffering';
  if (playing && window._cast.lastServerNow && window._cast.lastOffset != null) {
    const delta = Date.now() - window._cast.lastServerNow;
    if (delta > 0) off = Math.min(dur || Infinity, (window._cast.lastOffset || 0) + delta);
  }
  return Math.min(off, dur || Infinity);
}

/* ——— trwałe zapisywanie do localStorage (per itemId) ——— */
function saveCastStateLocally() {
  if (!window._cast.itemId) return;
  const key = 'piotrflix:cast:last';
  const packed = {
    item_id       : String(window._cast.itemId),
    title         : window._cast.title || '',
    view_offset_ms: Math.floor(currentCastOffsetMs()),
    duration_ms   : Math.max(0, Number(window._cast.durationMs) || 0),
    saved_at_ms   : Date.now()
  };
  try {
    const all = JSON.parse(localStorage.getItem(key) || '{}');
    all[packed.item_id] = packed;
    localStorage.setItem(key, JSON.stringify(all));
  } catch (_) {}
}

function loadSavedCastState(itemId) {
  const key = 'piotrflix:cast:last';
  try {
    const all = JSON.parse(localStorage.getItem(key) || '{}');
    return all?.[String(itemId)] || null;
  } catch (_) { return null; }
}

/* ——— szybki sync do backendu bez blokowania zamknięcia strony ——— */
function beaconSyncCastOffset() {
  if (!window._cast.clientId || !window._cast.itemId) return;
  const payload = {
    client_id     : window._cast.clientId,
    item_id       : window._cast.itemId,
    view_offset_ms: Math.floor(currentCastOffsetMs()),
    duration_ms   : Math.max(0, Number(window._cast.durationMs) || 0),
    state         : window._cast.state || 'unknown'
  };
  try {
    const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
    // Na backendzie zaimplementuj lekkie przyjęcie, np. /plex/cast/sync (idempotentne)
    navigator.sendBeacon?.('/plex/cast/sync', blob);
  } catch (_) {}
}

/* ——— Hooki cyklu życia strony (działają na desktop/mobile) ——— */
function installCastLifecycleGuards() {
  // Gdy karta staje się niewidoczna — zapisz i wyślij offset
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
      saveCastStateLocally();
      beaconSyncCastOffset();
    }
  });

  // Na iOS/Android Safari lepiej słuchać „pagehide”
  window.addEventListener('pagehide', () => {
    saveCastStateLocally();
    beaconSyncCastOffset();
  });

  // Fallback dla desktopów
  window.addEventListener('beforeunload', () => {
    saveCastStateLocally();
    beaconSyncCastOffset();
  });
}

// Zainstaluj strażników po załadowaniu
document.addEventListener('DOMContentLoaded', installCastLifecycleGuards);

/* ——— Dodatkowo: gdy tylko dostaniemy status z serwera — aktualizuj localStorage ——— */
const _origPollOnce = pollCastOnce;
pollCastOnce = async function patchedPollCastOnce() {
  await _origPollOnce();
  // po udanym ticku mamy świeże lastOffset/lastServerNow — zapisz lokalnie
  if (window._cast?.itemId) saveCastStateLocally();
};

/* ——— Na wejściu do strony: jeśli jest aktywna sesja, pokaż pasek i od razu zapisz stan ——— */
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const res = await fetch('/plex/cast/status');
    const data = await res.json();
    const s = (data.sessions || [])[0];
    if (s) {
      // (Twoja istniejąca logika inicjalizacji już to robi)
      // dorzucamy tylko pewny save po starcie:
      saveCastStateLocally();
    }
  } catch (_) {}
});

// ===== RANDOMIZER (Losowanie filmu po gatunkach, z animacją i bez 100%) =====
(function(){
  const fab       = document.getElementById('rand-fab');
  const modal     = document.getElementById('rand-modal');
  const listBox   = document.getElementById('rand-genres');
  const selectAll = document.getElementById('rand-select-all');
  const goBtn     = document.getElementById('rand-go');
  const cancel    = document.getElementById('rand-cancel');
  const statusEl  = document.getElementById('rand-status');

  const resModal  = document.getElementById('rand-result');
  const resPoster = document.getElementById('rand-poster');
  const resTitle  = document.getElementById('rand-title');
  const resCast   = document.getElementById('rand-cast');
  const resClose  = document.getElementById('rand-close');
  const rollingHint = document.getElementById('rand-rolling-hint');

  if (!fab) return;

  let filmsCache = null;     // [{id,title,thumb,progress}, ...]
  let genresList = [];       // ["Horror","Comedy",...]

  function openModal(){ modal.classList.add('show'); }
  function closeModal(){ modal.classList.remove('show'); }
  function openResult(){ resModal.classList.add('show'); }
  function closeResult(){ resModal.classList.remove('show'); }

  // unikalne gatunki z /plex/films
  async function ensureGenresLoaded(){
    if (genresList.length) return;

    statusEl.textContent = "Ładuję listę…";
    listBox.innerHTML = "";

    // pobierz listę filmów raz
    if (!filmsCache){
      const r = await fetch('/plex/films');
      filmsCache = await r.json();
    }

    const set = new Set();
    await Promise.all(filmsCache.map(async f => {
      try{
        const gs = await window.getGenresForId(String(f.id));
        gs.forEach(g => set.add(String(g)));
      }catch(_){}
    }));

    genresList = Array.from(set).sort((a,b)=>a.localeCompare(b,'pl'));

    const frag = document.createDocumentFragment();
    genresList.forEach((g, idx) => {
      const row = document.createElement('div');
      row.className = 'rand-row';
      row.innerHTML = `
        <input type="checkbox" id="rg-${idx}" data-genre="${g}" checked>
        <label for="rg-${idx}">${g}</label>
      `;
      frag.appendChild(row);
    });
    listBox.appendChild(frag);

    statusEl.textContent = genresList.length ? `Gatunki: ${genresList.length}` : 'Brak danych';
    selectAll.checked = true;
  }

  const pickRandom = arr => arr[Math.floor(Math.random() * arr.length)];

  // UI helpers dla rolling
  function setRollingUI(on) {
    if (!resModal) return;
    if (on) {
      resModal.classList.add('rolling');
      if (rollingHint) rollingHint.style.display = 'block';
    } else {
      resModal.classList.remove('rolling');
      if (rollingHint) rollingHint.style.display = 'none';
    }
  }

  fab.addEventListener('click', async () => {
    try{ await ensureGenresLoaded(); }catch(_){}
    openModal();
  });

  cancel.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if (e.target===modal) closeModal(); });

  selectAll.addEventListener('change', () => {
    listBox.querySelectorAll('input[type="checkbox"]').forEach(ch => ch.checked = selectAll.checked);
  });

  goBtn.addEventListener('click', async () => {
    const chosen = new Set(
      Array.from(listBox.querySelectorAll('input[type="checkbox"]:checked')).map(ch => ch.dataset.genre)
    );
    if (!chosen.size){
      alert('Zaznacz przynajmniej jeden gatunek');
      return;
    }

    // Kandydaci: film ma którykolwiek z wybranych gatunków + NIE 100% obejrzany
    const candidates = [];
    await Promise.all((filmsCache||[]).map(async f => {
      try{
        const prog = Number(f.progress) || 0;
        if (prog >= 100) return; // pomijamy ukończone
        const gs = await window.getGenresForId(String(f.id));
        if (gs.some(g => chosen.has(String(g)))) candidates.push(f);
      }catch(_){}
    }));

    if (!candidates.length){
      alert('Brak filmów w wybranych gatunkach (nieukończonych w 100%).');
      return;
    }

    // Rolling: pokaż modal wyniku w trybie „losuję…”
    closeModal();
    openResult();
    setRollingUI(true);

    // Zbuduj rotację plakatów (fallback na placeholder)
    const thumbs = candidates.map(c => c.thumb || 'https://via.placeholder.com/220x330?text=Poster');
    let idx = Math.floor(Math.random() * thumbs.length);
    resPoster.src = thumbs[idx];
    resTitle.textContent = 'Losuję…';

    // Szybka wymiana plakatów co 120ms przez 2200ms
    const tickMs = 120;
    const totalMs = 2200;
    let elapsed = 0;
    const timer = setInterval(() => {
      idx = (idx + 1) % thumbs.length;
      resPoster.src = thumbs[idx];
      elapsed += tickMs;
      if (elapsed >= totalMs) {
        clearInterval(timer);

        // Finalny wybór
        const picked = pickRandom(candidates);

        // Wyświetl wynik
        resPoster.src = picked.thumb || 'https://via.placeholder.com/220x330?text=Poster';
        resPoster.onerror = () => { resPoster.src = 'https://via.placeholder.com/220x330?text=Poster'; };
        resTitle.textContent = picked.title || '—';

        // Włącz CTA
        setRollingUI(false);

        // CAST + Zamknij
        resCast.onclick = () => {
          try { openCastModalForItem({ id: String(picked.id), title: picked.title || '' }); } catch(_) {}
          closeResult();
        };
        resClose.onclick = closeResult;
        resModal.addEventListener('click', (e)=>{ if (e.target===resModal) closeResult(); }, { once:true });
      }
    }, tickMs);
  });
})();

// ===== L I V E S E A R C H  (Dostępne: tytuł + gatunki) =====
(function(){
  const toggleBtn = document.getElementById('live-toggle');
  const panel     = document.getElementById('live-panel');
  const overlay   = document.getElementById('live-overlay');
  const closeBtn  = document.getElementById('live-close');

  const queryEl   = document.getElementById('live-query');
  const selectAll = document.getElementById('live-select-all');
  const statusEl  = document.getElementById('live-status');
  const genresBox = document.getElementById('live-genres');
  const countEl   = document.getElementById('live-count');
  const clearBtn  = document.getElementById('live-clear');

  if (!toggleBtn) return;

  const C_FILMS  = document.getElementById('available-films');
  const C_SERIES = document.getElementById('available-series');

  let films   = null; // /plex/films
  let series  = null; // /plex/series
  let allGenres = []; // posortowana lista unikalnych
  let isReady   = false;

  function openPanel(){
    panel.classList.add('show'); overlay.classList.add('show');
    panel.setAttribute('aria-hidden','false');
    queryEl?.focus();
  }
  function closePanel(){
    panel.classList.remove('show'); overlay.classList.remove('show');
    panel.setAttribute('aria-hidden','true');
  }

  // Debounce
  function debounce(fn, ms=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

  // Zbierz unikalne gatunki ze wszystkich pozycji (filmy+seriale)
  async function buildGenresIndex(){
    statusEl.textContent = "Ładuję gatunki…";
    if (!films){ const rf = await fetch('/plex/films'); films = await rf.json(); }
    if (!series){ const rs = await fetch('/plex/series'); series = await rs.json(); }

    const set = new Set();
    const toFetch = [
      ...films.map(x => String(x.id)),
      ...series.map(x => String(x.id)),
    ];

    // równolegle, ale upraszczamy błąd
    await Promise.all(toFetch.map(async id => {
      try{
        const gs = await window.getGenresForId(id);
        (gs||[]).forEach(g => set.add(String(g)));
      }catch(_){}
    }));

    allGenres = Array.from(set).sort((a,b)=>a.localeCompare(b,'pl'));
    renderGenreCheckboxes(allGenres);
    statusEl.textContent = `Gatunki: ${allGenres.length}`;
    isReady = true;
  }

  function renderGenreCheckboxes(list){
    genresBox.innerHTML = "";
    const frag = document.createDocumentFragment();
    list.forEach((g,i)=>{
      const row = document.createElement('div');
      row.className = 'live-row';
      row.innerHTML = `
        <input type="checkbox" id="lg-${i}" data-genre="${g}" checked>
        <label for="lg-${i}">${g}</label>
      `;
      frag.appendChild(row);
    });
    genresBox.appendChild(frag);
    selectAll.checked = true;
  }

  // POBIERZ ATRYBUTY z kart (tytuł + gatunki)
  function readCardData(el){
    const title = (el.dataset.title || el.querySelector('b, .series-title')?.textContent || '').toLowerCase();
    const gsStr = (el.dataset.genres || '');
    const gs = gsStr ? gsStr.split('|') : [];
    return { title, genres: gs };
  }

  // Zastosuj filtr do wszystkich kart
  function applyFilter(){
    const q = (queryEl.value || '').trim().toLowerCase();
    const selected = new Set(
      Array.from(genresBox.querySelectorAll('input[type="checkbox"]:checked')).map(ch => ch.dataset.genre.toLowerCase())
    );
    const genreFilterOn = selected.size > 0 && selected.size < allGenres.length;

    let visible = 0;

    // FILMY
    if (C_FILMS){
      C_FILMS.querySelectorAll('.browse-result').forEach(el=>{
        const { title, genres } = readCardData(el);
        const qOk = !q || title.includes(q);
        const gOk = !genreFilterOn || genres.some(g => selected.has(g.toLowerCase()));
        const show = qOk && gOk;
        el.classList.toggle('hidden-live', !show);
        if (show) visible++;
      });
    }

    // SERIALE (tylko karty seriali, nie odcinki)
    if (C_SERIES){
      C_SERIES.querySelectorAll('.series-card').forEach(el=>{
        const { title, genres } = readCardData(el);
        const qOk = !q || title.includes(q);
        const gOk = !genreFilterOn || genres.some(g => selected.has(g.toLowerCase()));
        const show = qOk && gOk;
        el.classList.toggle('hidden-live', !show);
        if (show) visible++;
      });
    }

    if (countEl) countEl.textContent = `Widoczne: ${visible}`;
  }

  // Zdarzenia UI
  toggleBtn.addEventListener('click', async ()=>{
    if (!isReady){
      try { await buildGenresIndex(); } catch(_){}
    }
    openPanel();
    applyFilter(); // policz widoczne na starcie
  });
  closeBtn.addEventListener('click', closePanel);
  overlay.addEventListener('click', closePanel);

  queryEl.addEventListener('input', debounce(applyFilter, 90));
  selectAll.addEventListener('change', ()=>{
    const on = selectAll.checked;
    genresBox.querySelectorAll('input[type="checkbox"]').forEach(ch => ch.checked = on);
    applyFilter();
  });
  genresBox.addEventListener('change', debounce(applyFilter, 60));

  clearBtn.addEventListener('click', ()=>{
    queryEl.value = '';
    selectAll.checked = true;
    genresBox.querySelectorAll('input[type="checkbox"]').forEach(ch => ch.checked = true);
    applyFilter();
  });

  // ===== integracja: gdy karty się tworzą, dołóż data-* atrybuty =====
  // helper do ustawienia data-genres po renderze badge’y
  window.attachGenresData = async function(elCard, itemId){
    try{
      const gs = await window.getGenresForId(String(itemId));
      // zapis w elemencie kontenera karty (do filtrowania)
      const holder = elCard; // dla filmów: .browse-result, dla seriali: .series-card
      if (holder){
        const norm = s => String(s||'').trim().toLowerCase();
        holder.dataset.genres = (gs||[]).map(norm).join('|');
      }
    }catch(_){}
  };

})();

document.addEventListener('DOMContentLoaded', () => {
  const liveBtn = document.getElementById('live-toggle');
  if (!liveBtn) return;

  // jeśli startujesz na "Torrenty", schowaj; jeśli ktoś zmieni – showSection to ogarnie
  const isAvailActive = document.getElementById('section-available')?.classList.contains('active');
  liveBtn.style.display = isAvailActive ? 'grid' : 'none';
});

/* ====== NAWIGACJA — izolowany JS ======
   - brak globalnych kolizji; używa tylko #nawigacja
   - jeżeli istnieje window.showSection, wywoła go
   - sekcje rozpoznaje po klasie .section i id: section-<name>
*/
(function(){
  const root = document.getElementById('nawigacja');
  if(!root) return;

  const btns = Array.from(root.querySelectorAll('.nawigacja__btn'));
  const STORAGE_KEY = 'nawigacja:lastSection';

  function setActive(section){
    // przyciski
    btns.forEach(b=>{
      const active = b.dataset.section === section;
      b.classList.toggle('is-active', active);
      b.setAttribute('aria-selected', active ? 'true' : 'false');
    });

    // sekcje (jeśli są na stronie)
    document.querySelectorAll('.section').forEach(sec=>{
      const key = (sec.id || '').replace('section-','');
      const on = key === section;
      sec.classList.toggle('active', on);
      sec.hidden = !on;
    });

    try{ localStorage.setItem(STORAGE_KEY, section); }catch(_){}
    try{ history.replaceState(null, '', '#'+section); }catch(_){}
  }

  // podpinamy na klik
  root.addEventListener('click', (e)=>{
    const b = e.target.closest('.nawigacja__btn');
    if(!b) return;
    const section = b.dataset.section;
    setActive(section);

    // współpraca z istniejącą showSection()
    if (typeof window.showSection === 'function') {
      try { window.showSection(section); } catch(e) {}
    }
  });

  // start: hash > localStorage > domyślnie torrents
  let start = 'torrents';
  const hash = (location.hash || '').replace('#','');
  if (/^(torrents|search|browse|available)$/.test(hash)) start = hash;
  else {
    try{
      const ls = localStorage.getItem(STORAGE_KEY);
      if (ls) start = ls;
    }catch(_){}
  }
  setActive(start);

  // opcjonalnie udostępniamy API
  window.nawigacjaSetActive = setActive;
})();
</script>







